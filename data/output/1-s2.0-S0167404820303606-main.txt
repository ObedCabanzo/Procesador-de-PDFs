# Android security assessment: A review, taxonomy and research gap study
Shivi Garg a,b,∗, Niyati Baliyan a
a Information Technology Department, Indira Gandhi Delhi Technical University for Women, Delhi, India
b Faculty of Informatics and Computing, J.C. Bose University of Science and Technology YMCA, Faridabad, India
# Article information
Article history:
- Received 30 June 2020
- Revised 8 September 2020
- Accepted 13 October 2020
- Available online 28 October 2020
# Keywords
Android, Dynamic analysis, Hybrid analysis, Machine learning, Security, Static analysis, Systematic literature review
Security threats are escalating exponentially posing a serious challenge to mobile platforms, specifically Android. In recent years the number of attacks has not only increased but each attack has become more damaging to the platform. Therefore, it is important to develop more stringent counter-measures to defend the mobile systems. Although in the last few years significant research progress is seen in the field of the detection and mitigation of Android security, yet numerous challenges and gaps still exist. This paper presents a comprehensive and sound taxonomy to review the state-of-the-art approaches used in Android security. We have highlighted the trends and patterns of different analysis approaches, identified the key aspects in terms of objectives, analysis techniques, code representations, tools and frameworks used, etc. and enumerated the research areas for future work. To carry out this study, the proper systematic literature review process is followed and the results of nearly 200 research publications have been comprehended based on different security aspects.
© 2020 Elsevier Ltd. All rights reserved.
# 1. Introduction
Google’s Android is the most prevalent mobile platform among different smartphone platforms. Android’s market share is ∼73% as of 2020 (Statcounter GlobalStats 2020). According to Google, there are ∼2 Bn active Android devices in 2019, making Android the most popular mobile platform amongst users . Growing mobile app markets have increased security threats and are specifically targeting mobile platforms. A large number of Android app markets contain vulnerable and malicious apps, thereby compromising millions of mobile devices. The malicious apps can cause severe repercussions such as privacy leaks, app crashes, financial losses (caused by malware triggered premium rate SMSs) and arbitrary code installation, etc. Hence, Android security is a major concern amongst researchers as seen in the last few years.
# 1. Motivation
The researchers have investigated Android’s security features that overlap with different domains like software engineering, programming language analysis, and mobile computing. The existing knowledge base in this field is present as published literature. However, the current literature is not comprehensive and does not provide a holistic view of state-of-the-art approaches. This paper provides an exhaustive review of all the existing approaches in a structured format. The objectives of this paper are:
1. To identify different purposes of Android security assessment techniques
∗ Corresponding author at: Information Technology Department, Indira Gandhi Delhi Technical University for Women, Delhi, India. E-mail addresses: shivi002phd16@igdtuw.ac.in (S. Garg), niyatibaliyan@igdtuw.ac.in (N. Baliyan).
https://doi.org/10/j.cose
0167-4048/© 2020 Elsevier Ltd. All rights reserved.
# Computers & Security 100 (2021) 102087
# 1. Introduction
# 1. Objectives
To propose a taxonomy of Android security analysis approaches employed a centralised network topology where a centralised server controlled the scheduling of tasks. Although cluster computing reduced execution time and increased the system performance, yet the standalone computer systems were not able to handle large computations. Hence, this led to the development of grid computing (GC) in the 1990s. GC networks were distributed and had decentralised network topology. It offered three-pronged benefits i.e. resource shareability, system scalability, and computing reliability, but it suffered from data confidentiality and integrity issues (Agarwal and Srivastava, 2017). In 1999 introduction to Salesforce.com provided a breakthrough in cloud computing (CC) that allowed users to avail remotely accessible services as a platform (PaaS), infrastructure (IaaS), and software (SaaS) (Bhatia and Verma, 2017). CC helped in offloading resource-heavy tasks to cloud servers however, there were security and privacy issues. Therefore, the ubiquitous computing (UC) paradigm became popular in the 2000s. UC introduced seamless access to remote information resources with high fault tolerance, availability, and security. However, the major drawbacks of UC were energy consumption and human-machine interference . The year 2006 marked the inception of the concept of the Internet of Things (IoT) in which the computing devices are interconnected via the Internet. IoT provides support for complex event processing (CEP) (García-Valls et al., 2018) and is a unique feature in comparison to other computing paradigms.
# 1. Our contributions
The unique contributions of this paper are:
1. Better publication coverage from 2013 – 2020
2. Proposing more deep and comprehensive taxonomy of Android security analysis approaches
3. Covering all the program analysis approaches from static to Machine Learning (ML) including semi-supervised, reinforced and Deep Learning (DL)
4. Focusing on all the major security issues such as vulnerabilities, privacy leaks, app cloning, permission misuse, cryptographic issues, malware detection, test case generation, code verification and energy consumption
# 1. Paper organization
The structure of the paper is as follows. Section 2 talks about the evolution of computing paradigms and mobile phones over a period of time. Section 3 presents related surveys carried out in the Android security domain. Section 4 mentions the research methodology and fundamental protocol for this SLR. Section 5 presents the taxonomy constructed from the existing literature. Section 6 presents the research gaps and provide future directions for the Android security research community. Potential threats to validity and multiple ways to mitigate those are discussed in Section 7. Finally, the paper is concluded in Section 8.
# 2. Evolution of computing paradigms and mobile phones
With technological advancements, Internet speed and bandwidth have improved considerably over the years. The computing paradigms have evolved and gone through multiple stages of advancements. Fig. 1 reflects this evolution of computing paradigms and their effect on mobile phones (and Android).
The 1980s marked the era of cluster computing, during which the same type of standalone computer systems were interconnected using a high-speed local area network (LAN) (van Steen and Tanenbaum, 2016). Cluster computing de-
Despite security improvements over the years, Android still suffers from multiple vulnerabilities, potential threats, and malware attacks. Users can detect malicious applications by analyzing the permissions model of Android. Malware in An-
# Computers & Security 100 (2021) 102087
# Computing
# Small Homogenous Cluster
# Grid Computing
# Cloud Computing
# Ubiquitous Computing
# IoT & Decentralized Ledger
# Evolution of Mobile Phones
droid can exploit vulnerabilities to obtain root-level access and can do nasty things. Different layers in Android OS software stack are affected by multiple vulnerabilities (Mazuera-Rozo et al., 2019). Fig. 2 shows the distribution of different vulnerabilities across the Android OS layers. The enhancements in the software stack of Android have reduced the number of vulnerabilities, however the basic framework is same in all the Android versions. The threat of malware on Android is real and will continue to grow, therefore it is important to study different analysis techniques, which can provide some real benefits and protection to the users.
# 3. Related Surveys
It is important to identify, examine, and understand the contributions in the field of mobile security since the emergence of mobile phones. To the best of our knowledge, this study is first of its kind dealing with Android security analysis. There is no other survey that particularly focuses on all the aspects of Android security. Multiple works and surveys related to Android security have been proposed in the literature. There are very few SLRs existing in the Android security domain however, they lack completeness and comprehensiveness.
Suarez-Tangil et al. (2013) reviewed the malware evolution and analyzed 20 research efforts that detected mobile malware. Haris et al. (2014) presented a survey on mobile computing that addressed issues related to privacy. This study comprised of 16 user studies and 13 privacy leak detection tools in mobile privacy. Shrivastava et al. (2019) surveyed on the privacy issues caused by permissions in Android application.
The survey of Rashidi and Fung (2015) focused on the current security threats in Android and security implementation solutions. They classified security mechanisms in Android into four different dimensions: Denial of Service (DoS) attacks, Information Leaks, App Cloning and Vulnerabilities.
Another survey of Tan et al. (2015) discussed static and dynamic analysis approaches. They proposed taxonomy with five categories of existing security solutions on Android. They concluded that static analysis is the most leveraged technique for addressing Android security issues.
In another survey, Martin et al. (2016) analyzed the works based on the app store in the field of software engineering. The authors reported the technical and non-technical learning behaviors of software repositories. In particular, they analyzed existing works in 7 dimensions such as feature analysis, API analysis, review analysis, store ecosystem, security, size and effort prediction, and others.
In the survey of Faruki et al. (2014), they focused on the malware growth, anti-analysis techniques, and malware detection techniques. They also discussed that stealthy techniques such as encryption and code transformation can generate variants of malware. They analyzed static and dynamic approaches for malware detection.
In a technical report presented by Sadeghi et al. (2016), a qualitative comparison of program analysis techniques was done based on Android security. They proposed the taxonomy after reviewing 336 research papers, including both static analysis and dynamic analysis approaches. However, the very less focus was on the hybrid and ML techniques supplementing the conventional analysis approaches.
|Android 1 (Cupcake)|2009|- Very little software vetting
- Pro-Police to prevent buffer overflows
- Safe integer operations to reduce integer overflows
|
|Android 2 (Éclair)|2009|- Handled null pointer dereference privilege escalation
- Prevention of code execution on the heap and stack
- Format string vulnerability protections
|
|Android 3 (Honeycomb)|2011|- Encryption of all user data
- Write access to memory cards not allowed to applications
- HTTPS stack improvement with Server Name Indication (SNI)
|
|Android 4 (Ice Cream Sandwich)|2011|- SELinux support
- ASLR to randomize key locations in memory
- Read-only relocations / immediate binding
- Handled kernel addresses leakage
- Verified boot
|
|Android 5 (Lollipop)|2014|- Improved full disk encryption
- Smart Lock
- Android sandbox reinforced with SELinux
- Updated cryptography for HTTPS and TLS/SSL
- Kill-switch option for full factory reset
|
|Android 6 (Marshmallow)|2015|- Automatic update security patches on a device
- Runtime Permissions
- Hardware-Isolated Security
- Fingerprints
|
|Android 7 (Nougat)|2016|- File-based encryption
- Verified and Direct boot
- Kernel hardening
- Updated SELinux
- Improved ASLR
|
|Android 8 (Oreo)|2017|- Google Play Protect to automatically scan Google play store
- Verified boot with Rollback protection
- Tight Sandboxing with Webview
- User-space and Kernel hardening
|
|Android 9 (Pie)|2018|- Support for biometrics
- APK signature scheme v3
- Support for kernel control flow integrity (CFI)
- Default HTTPS for apps
- Passcode for device restoration
|
|Android 10 (Quince Tart)|2019|- Support for the WPA3 Wi-Fi security protocol
- Device and File-based encryption mandatory for all devices
|
# 4. Research methodology
The research methodology used to prepare this SLR is based on the general guidelines proposed by Kitchenham and Brereton (2013). 200 research papers published in reputed journals and conferences with a significant number of citations are studied and analyzed. We have compared different concepts presented in the proposed taxonomy to identify the current trends and research gaps in the presented literature and provided future directions to the researchers that will shape the domain of Android security. Fig. 3 explains the protocol that is used to carry out this SLR.
The key steps in the formation of SLR are detailed below:
- Formulated research questions describing the purpose of the SLR (cf. Section 4).
- Enumerated distinct search keywords to find prominent journals and conferences (cf. Section 4). The searching process considered two scenarios, first one focused on finding reputed publication repositories while the second one focused on publications from top venues including conferences, workshops, and symposia (cf. Section 4).
- Applied inclusion/exclusion criteria to filter retrieved papers that fit in the scope (cf. Section 4).
# Computers & Security 100 (2021) 102087
# APK
# System Applications (Java)
8%
Android Manifest
Permissions
Contacts
IPC
Phone
IPC
Email
# Application Framework (Java)
5%
Activity Manager
Content Providers
Window Manager
Package Manager
Telephony Manager
# Native Libraries (C/C++)
30%
Media
SQLite
FreeType
SSL
OpenGL
Graphics
Libc
WebKit
# Android Runtime
1%
Core Libraries
Dalvik Virtual Machine
# Hardware Abstraction Layer (Vendor specific)
1%
Camera
Audio
Bluetooth
Sensors
# Linux Kernel (C)
52%
Binder (IPC)
Keypad Driver
Display Driver
USB Driver
Power Management
- Performed citation chaining to refine the search process studied remaining issues that are still open for current research efforts.
- Results from different research findings are combined to carry out future research (cf. Section 4).
# 4. Search strategy
# 4. Research questions (RQ) identification
This SLR aims to answer the following research questions (RQs):
1. RQ1: What are the different approaches to analyze Android security? To answer this survey-of-surveys is built with complete taxonomy for classifying Android security analysis approaches.
2. RQ2: How are these analysis approaches designed and implemented? For this question, research results cataloged during SLR are reviewed to understand concepts and techniques of implementation.
3. RQ3: What is the current state-of-the-art concerning Android security? To answer this, research articles are categorized across multiple dimensions that help perform quantitative/qualitative analysis.
4. RQ4: What research gaps and challenges need to be inferred and addressed? Finally, with this question, we...
# 4. Search keywords
The focus is on specific keywords to confine the scope of the literature review. The keywords are searched on the papers’ title, abstracts, and meta-data like tags. Table 3 describes the research domains and the related keywords that appear in these domains.
There are three research domains, denoted by R, which fit in the scope of the SLR. These are as follows:
1. Android Mobile OS – this domain focuses on a mobile platform and target programs.
2. Technical Approach – this domain includes the analysis techniques- static, dynamic, hybrid or ML.
3. Security Aspects – this domain covers the analysis methods to be applied to the potential security issues.
# Computers & Security 100 (2021) 102087
# Identily Research Questions (RQ)
- RQ 1
- RQ 2
- Review Papers in Detail
# Search Keywords
Analysis techniques; Static. Dynamic; Hybrid. ML
Android Malware, Vulnerability
# Search Repository
ACM; IEEE. Springer etc.
# Check Venues
NDSS; CCS; FSE; SEC, etc.
# Design & Implementation
Analysis Schemes
# Apply Inclusion & Exclusion Criteria
RQ 3
Study Current State-of-the-Art
# Identify Research Gaps & Challenges
RQ 4
# Future Research Directions
# Computers & Security 100 (2021) 102087
The search query (q) is a conjunction of the three research domains, namely, R1: Android Mobile OS, R2: Technical Approach, R3: Security Aspects, where R1, R2, R3 ∈ R. Each domain in the search query string is represented as a disjunction of its corresponding keywords (K), as shown in Table 1.
The search query is:
q = ∧r ∈ {R1, R2, R3} ∧keywords∈Kr keyword
In simplified form,
q = R1 AND R2 AND R3
R1 = {Android OR Smartphone OR Mobile OR App∗ OR Application}
# 4. Search repositories and datasets
We have considered reputed electronic repositories such as IEEE Xplore Digital Library, Science Direct, ACM Digital Library, and Springer Link to find relevant datasets of publications. Some repository search engines pose a limit to download to the search result meta-data. In that case, the search string is split and iterated over multiple times to retrieve the relevant results.
Other data sources such as conference proceedings, workshops and symposia that are not listed in the aforementioned repositories are also considered. To make our search exhaustive, we considered top 15 publication venues from security and privacy (S&P) field and software engineering and programming languages (SE/PL) field ranked according to the H-Index, as summarised in the Table 4. The H-Index of a publication as defined by Google Scholar is the count of h (largest value) published papers by a given author/journal that each been cited at least h times . It is considered that larger the value of H-Index, the better is the venue.
# 4. Selection criteria
A selection criterion viz. inclusion/exclusion is used to filter out the research results, since all the retrieved results do not lie in the scope of this SLR.
# 4. Inclusion criteria
We have limited the scope of the SLR that lie at the intersection of three research domains (discussed in the Section 4). We have collected the papers from 2013–2020.
# 4. Exclusion criteria
Exclusion criteria followed in this SLR are:
1. Research publications written in English are only considered since it is the most common language spoken by reviewers and researchers. Publications written in non-English are omitted.
Research papers published after June 2020 are not included in this SLR.
# Malware/Static
# 1. Short papers with page length of less than
4 pages in IEEE/ACM-like double-column format or with less than 7 pages in LNCS single-column format are rejected. These papers are preliminary works, which are later published as full-length papers and so should be included in the final set.
# 2. Duplicate papers
Duplicate papers that are first published in conference proceedings and later on extend in the journals are excluded. Such papers are identified by comparing the author list, paper title, abstract and meta-data.
# 3. Search term
Search term contains keywords such as “Mobile”, “Smartphone”, to retrieve good volume of papers. However, the retrieved result set includes papers about “Windows/iOS” platforms, “mobile networking”, etc. Therefore, non Android-related publications are excluded from this study.
# 4. Papers published before 2013
Papers published before 2013 are excluded from the SLR to include the recent trends and researches.
# 4. Backward and forward citation
# 4. Research publication selection
Results of final selection of publications are described in the Table 5. In Row 1, keyword-based search is performed on the research databases and initial set of papers are obtained. The search engine of each database treats the search query differently; therefore, initial filtration is performed over the initial set of papers as specified in Row 2. Row 3 shows the merged results from all the databases. Finally, selection criterions’ consisting of inclusion and exclusion criteria are applied to get the final set of selected papers. This process yields total of 200 research publications required to carry out this SLR.
Distribution of published papers in journals such as IEEE, ACM, Elsevier, and Springer is shown in Fig. 6. IEEE and ACM digital library form the largest share of published papers followed by Springer and Elsevier. Others include publications from IGI Global, Wiley and non-official proceedings such as arXiv.
Citation chaining or reference mining is a method to expand the research. It identifies additional relevant articles by reviewing the cited works/bibliographies/references list of a specific article from the search list (Citation chaining in Google Scholar and PubMed, 2020). The article can be traced both in backward and forward direction.
# 5. Taxonomy construction
After retrieving the relevant papers, taxonomy based on Android security analysis is constructed using properties and dimensions from the existing literature. This taxonomy of information will be helpful in order to (1) answer the above enumerated RQs, (2) provide systematic assessment of each paper, and (3) present a basis for categorizing and comparing the different approaches. The aforementioned surveys or SLRs described in Section 3, though relevant and useful, are not sufficient enough to categorise Android security analysis approaches.
1. Backward Chaining – It helps in finding those articles that are cited in the existing resources. It identifies past resources regarding the same topic.
2. Forward Chaining – It helps in finding those articles that cite the existing resources. Research databases such as Web of Science and Scopus are used for forward chaining. They show a list of references for a particular work if that item has been cited by other works in those particular databases.
Thus, we have defined the novel taxonomy to help classify existing work in this domain. Fig. 7 describes the defined taxonomy.
# Computers & Security 100 (2021) 102087
# 5. Android security analysis objectives
This dimension identifies different objectives for which analyses are performed. Several security issues are addressed while performing such analyses. Some of these are permission management concerns, code verification problems, automation of test case generation, private data leaks, clone detection, assessing code efficiency in terms of energy consumption, etc. This SLR identifies 9 objectives of Android security analysis approaches. The statistics of the different approaches targeting these objectives are also presented as follows.
1. Permission exploitation: Permission-based security model forms the basis of Android architecture. Permissions must be granted to access the system resources. However, some inherent risks are associated with the permissions since apps can leverage extra permissions what they actually need . Malicious apps can control permissions and can launch different types of attacks such as data loss attacks, data integrity attacks, DoS and Distributed DoS (DDoS) attacks.
2. Passive content leaks: It is also referred to as leaking private data. Privacy of data is the major concern among Android researchers. Potential privacy data leaks include phone information, WiFi data, GPS location, audio recorded with the microphone, etc.
3. Code verification: The purpose of the code verification is to ensure the correctness of a given app. There are very few works addressing this purpose. Cassandra  checks whether apps in Android are in compliance with their privacy requirements before app installation.
4. Misusing cryptography techniques: Implementation issues in cryptography are another cause of concern among the researchers. Cryptography misuse includes validation failure in the SSL/TLS resulting in man in the middle (MITM) attacks that violate the system authentication. CMA  analyses cryptography misuse using crypto misuse analyzer.
5. Vulnerability detection: Android suffers from large number of security vulnerabilities. Intent injection and content hijacking are most common vulnerabilities in Android. Intent injection occurs due to the execution of arbitrary code by manipulating the user data. Content hijacking occurs when private and protected resources are accessed in an unauthorised way through exported components in vulnerable apps. Epicc  uses static analysis for detecting inter-component vulnerabilities.
6. Energy consumption: Modern smartphones with large screen sizes have high energy consuming components. Battery stand-by time is a major concern for mobile devices. According to Li et al.  modern smart-
# Android Security Analysis
# Objective
Femi-sions
Lak
Cude
Cryptography
Vulnerability
Enctgy
Test ese
Clone
Malware
# Techniques
Phones consume more energy when the light colors are displayed compared to dark colors. They investigated that the energy consumption could be reduced by 40% by building dark background color web pages for the mobile systems to generate efficient web pages.
1. Test case generation: Test case generation provides a set of test cases that are executed for automatic and repeatable testing. Symbolic execution is performed on the source code to ensure the reachability of branches. As an example, SIG-Droid  is a framework for system testing of Android apps. It automatically generates test cases through symbolic execution using interface model and behavior model. Interface model finds the values that a given app can receive, whereas behavior model generates the sequences of events to drive the symbolic execution.
2. App Cloning: Researchers have used several analysis approaches to detect app cloning in Android. According to Mojica et al. (2013) app cloning is very common in mobile apps. In another work, AnDarwin  has proved to be efficient in detecting the cloned apps.
3. Malware detection: Vulnerabilities in Android are increasing leading to malware attacks. Malware can be of different types such as spyware, adware, Trojan, ransomware, etc., which can have a potential impact on the system. Therefore, modern studies are focusing more on malware detection.
Primary research publications serving these 9 objectives are enumerated in Table 6. Due to space constraints, these security objectives are represented in 25 clusters with the count of publications in each cluster as shown Fig. 8. Fig. 9 shows the statistics of the publications focusing on these security objectives. It is seen that majority of the studies focus on vulnerability detection (32%) followed by privacy leaks (28%) and malware detection (18%).
# 5. Android analysis techniques
The second dimension of the taxonomy, which tries to answer RQ1, is concerned with classifying the different techniques used in Android security analysis. There are four different program analysis techniques leveraged in the security domain of Android. These are Static, Dynamic, Hybrid and ML.
Static analysis examines the potential behavior of the program structure. These techniques parse the program source code or bytecode by traversing the program paths to check the properties of the program. Dynamic analysis observes the actual behavior of the program at runtime. In addition to pure static or dynamic techniques, there are hybrid techniques that leverage benefits from both static and dynamic techniques. In hybrid techniques, static analysis is first used to detect potential security concerns, and then dynamic analysis is used to eliminate the false warnings, thereby improving their precision. Apart from these techniques, other supplementary techniques such as ML are also used to complement the analysis. The program analysis either provides the input for, or consumes the output of, the supplementary techniques.
Each technique has its own merits and demerits according to their intrinsic properties. Static analysis techniques are sound and conservative however, dynamic analysis techniques are unsound but precise . In case of dynamic analysis, certain events are required to run the application.
# Computers & Security 100 (2021) 102087
# 12
# Computers & Security 100 (2021) 102087
Since it is not possible to record all the events at a time and so the provided test cases are likely to be incomplete, therefore, apps behaviors are captured. These results in false negatives, i.e., vulnerabilities or malicious behaviors are missed in the security analysis. Moreover, dynamic analysis approaches are often deceived by advanced malware, such as anti-taint tracking techniques bypass the dynamic taint analyses . Hybrid techniques have their own limitations that inhibit them from delivering impeccable results. It is seen that hybrid techniques have produced the worst results as those of static and dynamic techniques. ML approaches require large volume of data for training and hence demand for considerable amount of system resources and high computational power however, these problems can be resolved using DL.
# 5. Analysis techniques aspects
The third dimension talks about the different aspects of the program analyses techniques, which distinguishes them from each other. This dimension tries to answer RQ2 and RQ3, which is based on the design and implementation details of these approaches and current state of Android security. Seven
# Computers & Security 100 (2021) 102087
Sub-dimensions are discussed below, where the first four belong to static analysis techniques, the next two are applied to dynamic analyses and the last one is for ML techniques.
# 5. Analysis techniques
In this study, we have investigated six fundamental techniques. Table 7 shows the papers applying these analysis techniques. These are discussed as follows:
1. Symbolic execution: Symbolic execution helps analyze the program by determining different inputs executing different parts of the program. Inputs for propagating the program execution are symbolic values. These symbolic values are then used to generate variables, expressions and constraints that are used to produce possible outcomes for each conditional branch. These inputs are then used as test cases to explore the given path. The given path is considered to be infeasible when no input is produced. AppIntent  generates GUI manipulations sequences using symbolic execution that lead to data transmission. Symbolic execution proves to be time-consuming for Android apps; however, AppIntent reduces the search space without sacrificing the code coverage.
2. Taint analysis: It is a method of information flow analysis where an object is marked with an identifier, called as taint. The tainted object is then tracked using data-flow.
analysis. An exception is raised when a tainted object flows to a sink. FlowDroid  detects sensitive data leaks by using static taint analysis. AppSealer (Zhang and Yin, 2014a) generates patches for Android component hijacking attacks by leveraging taint analysis.
3. Program slicing: Program slicing is used to test a group of statements in a program for particular test cases or conditions that may affect a value at a particular point of time, while keeping the program behavior unchanged. Static program slices are large and consider all the possible execution program paths. Hoffmann et al. (2013) designed a framework SAAF. Program slices in SAAF track parameter values for a given Android method by performing backward data-flow analysis. CryptoLint  on the other hand, analyze cryptographic API methods by computing static program slices.
4. Abstract interpretation: Abstract interpretation is generally viewed as a partial execution of a program, where the semantics of a program such as data flow, control flow, etc. are taken into consideration.
5. Type/Model checking: Type and model checking are two commonly used approaches for program verification. Type checking verifies the type constraints of a program. It can occur either at compile time (static) or at execution time (dynamic). Type checking ensures the type-safety of a given program where there is a possibility of errors such as an integer operator applied to the strings or a float operation performed on an integer. On the other hand, model checking verifies the given specification of a finite-state system. Type and model checking are complimentary to each other where type checking is based on syntactic and modular style and model checking is based on semantic and whole-program style. As an example, COVERT  uses model checking to verify the security specifications of a given app. In another example, Cassandra  uses type checking to verify the compliance of Android.
# Computers & Security 100 (2021) 102087
# 5. Sensitivity analysis
Static analyses techniques are required to be precise and abstract. Analysing sensitivities can fine tune the precision of a static analysis. Thus, different types of sensitivities are applied on the static analyses techniques are discussed. Table 8 classifies the different approaches according to the sensitivities they take into consideration. Fig. 11 shows the distribution of publications according to the sensitivities.
1. Object Sensitivity: This approach distinguishes method calls made on different objects. The code in a method can call other methods to create instances of objects or manipulate existing objects.
2. Context Sensitivity: This approach keeps track of the calling context of a method call and compute separate information for different calls of the same procedure.
3. Flow Sensitivity: This approach considers the order of statements and computes the separate information for each statement.
4. Path Sensitivity: This approach analyses execution path taken and distinguishes the information obtained from different paths.
5. Field sensitivity: A field-sensitive approach models each field of each object.
Field-sensitivity appears to be the most prominent with ∼29% of the publications since Android is based on Java (Object-Oriented language), where object fields hold the data pervasively. Flow-sensitivity and Context-sensitivity are also considered largely (with 24% and 25% publications respectively). Only, 5% of the publications consider Path-sensitivity, primarily due to the scalability issues that it poses. It is considered that approaches that use more sensitivity are more precise in analysis. However, they are less scalable. Hopper  considers all the sensitivities into account and generate accurate results, but raises scalability issues.
# 5. Data structures
Heavyweight static analysis approaches that tend to give but more accurate results leverage well-known data structures to provide abstraction to the underlying programs. Table 9 shows the publications leveraging data structures.
1. Call Graph (CG): It is a directed graph, where each node indicates a method, and an edge represents the return from or call to a method.
2. Control Flow Graph (CFG): CFG is a directed graph that represents the basic flow of statements in a program. The nodes represent the program statements and edges denote the control flow of a program.
3. Inter-procedural Control Flow Graph (ICFG): It combines CG and CFG of all program procedures by connecting the call from and return to edges in the program procedure.
CGs (with 38%) are used to propagate taint information and to determine the source-to-sink reachability analysis. As an example, ContentScope (Jiang and Xuxian, 2013) detects database leakage by traversing CG to find paths from pub-
# 16
# Computers & Security 100 (2021) 102087
lic content provider interfaces to the database function APIs. PermissionFlow (Sbîrlea et al., 2013) maps Android permissions to the corresponding APIs by traversing CG. AsDroid  generates CG to track intent messages.
27% of the publications use CFGs in this SLR. As an example, in ContentScope (Jiang and Xuxian, 2013) CFG is used to extract the constraints corresponding to potentially dangerous paths. These constraints are then fed into a constraint solver to generate inputs corresponding to candidate path executions.
Another data structure is based on the combination of CFG and CG is ICFG that links the individual CFGs according to how they call each other. More advanced and comprehensive program analyses rely on ICFG. In FlowDroid , tainted variables are tracked by traversing ICFG. Epicc  traverses ICFG to perform string analysis. In IccTA  inter-component data leaks are detected by running data-flow analysis over ICFG. Only few approaches leverage ICFG since the generated ICFGs are complex and potentially not scalable.
# 5. Code representation
The intermediate representation (IR) of the code is a simplified format that represents the original Dalvik bytecode and processes it, since Dalvik bytecode is considered too complex and difficult to manipulate. Static analysis approaches are implemented as off-the-shelf frameworks that implement analysis on their own intermediate representation (IR) of program code. Various code representations and different tools used in static analysis approaches are enumerated in the Tables 10 and 11 respectively. The following code representations used in static analyses are:
1. Smali: This intermediate representation (IR) is Apktool, reverse engineering tool for Android apps.
2. Jimple: Jimple is known to be the simplified version of Java bytecode. It is used by Soot  framework. Soot uses Dexpler  plugin that translates Dalvik bytecode to Jimple IR.
3. WALA: WALA stands for T. J. Watson Libraries for Analysis. WALA IR is SSA-based representation that is built
# Computers & Security 100 (2021) 102087
on a Java/Javascript static analysis framework WALA (Fink and Dolby, 2012).
# 4. Java_bytecode/
code format called Dex. It is different from Java and is executable by the Android virtual machine (VM). Tools such as ded , Dare , and dex2jar (dex2jar 2020) translates Dalvik to Java bytecode prior to the analysis using APK-to-JAR transformers.
# 5. Dex_Assembler:
It disassembles DEX files using dedexer, dexdump and dx tools.
According to this study, Jimple is the most adopted IR (29%) and Soot is the most popular tool (25%) for static analysis of Android apps.
To monitor the runtime behavior of the source code of a program, dynamic analysis is performed. There are two main aspects with respect to dynamic analysis.
modifying VMs. There are two types of VMs-Dalvik VM and QEMU VM. Introspection based on Dalvik VM monitor the Android APIs execution through modifications in the Dalvik VM. QEMU based introspection are capable to trace native code. Dalvik VM are more efficient as compared to QEMU based VM. However, emulators are prone to emulator evasion .
# 2. Kernel-level:
API call execution can be monitored by collecting the system calls such as ltrace and strace using kernel modules. It allows partial tracing of the native code.
# 3. App-level:
This level of monitoring is also called method tracing, where Java method invocation can be traced by injecting the bytecode and log statements inside the original Android app code or framework.
# 5. Inspection level
Dynamic analyses are categorised based on the inspection levels. These are Emulator-based/ Virtual Machine (VM) level, Kernel-level and App-level. Table 12 lists the dynamic analysis techniques using different inspection levels.
1. Emulator-based/ Virtual Machine (VM)-level: This level inspects the events that occur within the emulators by monitoring system calls using kernel level inspection e.g., Andrubis .
# c o m p u t e r s & s e c u r i t y 100 (2021) 102087
# 5. Approaches
There are two main approaches for dynamic analysis: Taint analysis and Anomaly-based. Table 13 shows the list of publications using these approaches.
# 5. Methods
Various ML methods are: Supervised learning, Unsupervised learning, Semi-supervised learning, Reinforcement learning and Deep learning.
1. Taint analysis: This approach is similar to that of static taint analysis however, the tainted data is tracked during the program execution. TaintDroid  was the first technique to implement dynamic taint analysis however, it is out of the scope of this SLR.
2. Anomaly-based: This approach monitors regular behavioral activities in the device and looks for anomalies that deviate from the normal behavior. This approach tends to be more costly since it invokes large number of system calls .
Taint analysis approaches are more adoptable (27%) as compared to anomaly-based approaches (8%) in the surveyed literature because anomaly-based detection approaches prove to be costly in terms of system calls. Besides conventional program analysis techniques, there are other supplementary techniques such as ML to leverage the analysis. ML is a technique based on artificial intelligence, where the systems have the capability to learn from the available data, recognise patterns and can make decisions with least human intervention.
1. Supervised learning (SL): This class of algorithms takes known set of input data along with known responses to the output data and trains the model to generate predictions for the new dataset. Classification and regression are some of the well-known SL techniques. Classification is used to predict the discrete outcomes. Examples of classification algorithms are Naïve Bayes (NB), Support Vector Machine (SVM), Logistic Regression (LR), Decision Trees (DT), k-Nearest Neighbor (kNN) and Neural Networks (NN). For example, StormDroid  used SL for malware detection over 8000 apps with wide range of static and dynamic features. It achieved an accuracy of 93%. Garg and Baliyan (2019a) used parallel ensemble classifiers using Multi-Layer Perceptron (MLP), SVM, Pruning Rule-Based Classification Tree (PART), Ripple Down Rule Learner (RIDOR) to detect Android malware. They achieved an accuracy of 98%. Data processing and feature extraction details are given in Garg and Baliyan (2019b).
2. Unsupervised learning (UL): This class of algorithms draws inferences from the unlabeled input dataset. Clustering is commonly used UL technique. Common clustering algorithms are k-means, k-medoids, Hidden.
# 20
# Computers & Security 100 (2021) 102087
# % Distribution
Markov Models (HMM), etc. In Zarni Aung (2013) authors used k-means clustering algorithm cascaded with DT and Random Forest (RF) to detect Android malware. They achieved an accuracy of 91% for dataset 1 and 91% for dataset 2 using RF.
1. Semi-supervised learning (SSL): This class of algorithms combines both supervised and unsupervised learning techniques with some labeled and unlabeled data. In Mahindru and Sangal (2020), authors used Learning with Local and Global Consistency (LLGC), SSL method for malware detection with permissions and API calls as features and achieved an accuracy of 93%.
2. Reinforcement learning (RL): RL algorithms enable the agent to learn to achieve a goal in a potentially complex and uncertain environment by maximizing the cumulative reward. Some examples of RL are Deep Q Network (DQN), Deep Deterministic Policy Gradient (DDPG), Soft Actor-Critic (SAC), etc. Vuong and Takada (2019) proposed an automated GUI testing tool for Android applications using DQN. Authors have identified the semantic meanings of GUI elements and used them as an input to a NN, which through training approximates the behavioral model of the application under test.
3. Deep learning (DL): It is a class of ML algorithms that relates to the functioning of brain in the form of Artificial Neural Network (ANN). It has the capability to process large volumes of data. Well known DL algorithms are Deep Neural Networks (DNN), Convolutional Neural Network (CNN), Recurrent Neural Networks (RNN), Deep Belief Networks (DBN), etc. Pang et al. (2017) predicted vulnerable components and Java Android applications suing DNN and achieved an accuracy of 92%.
It is observed that most of the publications focus on DL (37%) since a large amount of data is easily processed by DL techniques. This is followed by supervised (29%) and unsupervised (18%) learning methods.
According to the “No Free Lunch” (NFL) theorem , there is no single ML model that is best suited for every problem. The assumptions of one model for a particular problem may not hold for another problem therefore, multiple ML models can be tried and tested to find the one that works best for a particular problem.
# 6. Discussions and future research directions
While investigating the SLR, many discussion points hover around. To address the fourth research question (RQ4), various challenges and gaps are identified and potential future research directions are then presented.
# 6. Cross-analysis
This study is further extended to the different directions of the proposed taxonomy. The aim is to perform cross-analysis to get a clearer vision of the Android security analysis.
It is important to introspect the recurrent purposes of Android security addressed by program analysis techniques. It is observed that static and dynamic analysis approaches are used for detecting data leaks and vulnerabilities. The static techniques are generally used for detecting privacy data leaks than vulnerabilities (50% vs. 34%), while dynamic techniques are frequently leveraged for vulnerability detection than data leaks and malware detection (58% vs. 41%). Hybrid approaches, though at lower scales are mostly used for the vulnerability detection (19%) whereas ML approaches are widely used in malware detection (56%).
Another element of cross-analysis is the depth of the analysis techniques, i.e., at the application level or the framework level. The application-level analyzes the application software. Apps from unknown third party market stores pose a serious security challenge. Framework-level analyzes the potential system-level design flaws and issues encountered in the Android platform. It is observed that the dynamic approaches are more often leveraged for framework-level analysis (∼55%). This is because dynamic approaches can track implicit relations between the Android permissions and system calls by deploying runtime modules, such as monitors in the Android framework. Moreover, the large code size of the Android framework (over ten million lines of code) makes it impossible for the static analysis approaches to monitor the runtime framework-level activity. Thus, dynamic techniques tend to be more scalable and less-expensive for framework-level monitoring.
# 6. Challenges posed by Android specificities
The inherent characteristics of Android pose several challenges for analysis techniques. These are listed as app component lifecycle, Inter-component Communications (ICC), XML file, and permissions. Component lifecycle callback methods such as onStart(), onStop(), onPause(), etc. are not connected with the apps or amongst themselves. Therefore, it is difficult for static analysis techniques to construct CFGs. ICC is a
# Computers & Security 100 (2021) 102087
message-passing mechanism used by the applications insu- not be altered at runtime. Permissions are building blocks of the Android security model. The permissions present in the manifest file of an app grant access to the various resources and cross-application interactions. Recent versions of Android employ dynamic permission management where users are allowed to revoke permissions at run time. Several research publications have widely discussed the shortcomings posed by permission model like least privilege principle violated by
# Computers & Security 100 (2021) 102087
Coarse-grained permissions , delegation attacks caused by enforcing access control policies at the level of individual , ignorance by end-users due to lack of permission awareness , and misusing permissions . Other challenges are related to Java since Android applications are written in Java and hence face issues like reflection, managing of dynamic code loading, multithreading, polymorphism, and integration of native code.
Procedure of code signing where developers can verify an authorship of an application. A User ID (UID) is assigned to digitally sign the application based on the digital certificate. If the same certificate is used to sign multiple applications then android:sharedUserId key is specified in the manifest file to share the same UID. This key can cause non-deterministic behavior when assigning the UID (Cr ˘aciunescu, 2020).
# 6. Future directions
The proposed taxonomy uncovers various research gaps and challenges that need more focus on analysis approaches used in Android security. The following research directions are presented to the research community to stay ahead of today’s advancing security threats:
# 7. Threats to validity
This SLR outlines different threats to validity to highlight the potential impact and measures for mitigation.
# 7. Construct validity
1. Android Security will remain a strong focus of research: Threats to construct validity can arise because of keywords-based search performed on repositories and conference venues. The overall publication list may not be exhaustive since only the top 15 conference venues are taken into consideration that are related to SE/PL and S&P domains. However, the attempt to search top-ranked venues guarantees that the influential 15 papers are taken into account. To mitigate this, citation chaining is done that helps reap the best-related papers. In addition, the iterative keyword-based search is incorporated to refine the search results timely.
2. Integrating multiple analytical approaches to obtain more precise and accurate results: Relying on the single technique will never give the best result due to their inherent limitations. More reliable hybrid techniques along with ML and DL, consolidating the advantages of both static and dynamic approaches could be leveraged for high precision analysis.
3. Analyzing different code forms for thorough analysis: Apart from Java, other code forms are also present in Android apps such as native C/C++, Dalvik bytecode, and binaries. Dynamic code loading (DCL)  and reflection  are used to access Dalvik bytecode, whereas the Java Native Interface (JNI) API  is used to access binaries. Very few state-of-the-art static analysis approaches have considered DCL and JNI for analysis, thereby obtaining incomplete results.
4. Shifting from single app analysis to system-level analysis to unfold compositional vulnerabilities: Malware writers can easily exploit the vulnerabilities of multiple benign apps. However, most of the studies in the existing literature focus on single app or individual system components. As an example, Bagheri et al. (2015c) analyzed the permission protocol of Android to check the security requirements of preventing unauthorized access. It is challenging to identify such attacks that require complete system analysis rather than analyzing individual parts of the system in isolation. Therefore, it is important to completely analyze vulnerabilities to predict all the possible ways to exploit the vulnerabilities at the system level.
5. Focusing on repudiation: The search process employed in this SLR retrieved no results for Android repudiation. The research community should take into account the potential threats and weaknesses that are caused by the vetting process of the Android. Vetting process is a pro-
# 7. Internal validity
Threats to internal validity can be primarily due to limited and focused searches on the topic concerned. It is primarily related to the soundness of proposed taxonomy, i.e., whether the proposed taxonomy can categorize the different aspects of Android security. To handle this, an iterative-content analysis method is employed, where the taxonomy is evolving constantly to account for new concepts and ideas encountered in the papers.
# 7. External validity
The analysis based on this study is performed on the research publications collected from 2013–2020, to cover all possible approaches used in Android security to date. Though, the trends may vary for different time-period.
# 7. Conclusion validity
The threat may also occur due to consideration of studies with individual reviewer’s bias. This may lead to flaws and biases in our study. To maintain the objectiveness cross-checking mechanism is applied, where a thorough examination is done to ensure that no paper is reviewed by a single reviewer. To further minimise the individual reviewer’s bias, inferences made in this SLR are based on cumulative and general observations from different papers rather than relying on a single reviewer’s interpretation.
# 24
# Conclusion
With the growing security threats in mobile platforms, particularly Android has led to considerable research efforts in the domain of Android security. This paper presented the state-of-the-art approaches concerning Android security. To achieve this, a comprehensive taxonomy is constructed for categorizing different aspects of Android security. A formal process of SLR is followed by analyzing 200 research papers published in the domains of security and privacy, software engineering, programming languages, and mobile computing from 2013 to 2020. The search strategy and selection criteria employed in this article play a key role in making this study more sound and complete. It is evident from the results of SLR that Android security has gained a lot of focus in the last few years primarily due to the popularity among mobile platforms as well as increasing incidents of malware and vulnerabilities. To summarise, this study points out (1) the purposes of multiple analysis approaches, (2) most of the analysis approaches are built on Soot framework, (3) taint analysis is the most used analysis technique, (4) path sensitivity is ignored by the majority of the research works, (5) integrated analysis techniques prove to be much beneficial than pure static or dynamic approaches.
# Declaration of Competing Interest
The authors declare that they have no known competing financial interests or personal relationships that could have appeared to influence the work reported in this paper.
# Computers & Security
# 100 (2021) 102087
Caputo D, Verderame L, Aonzo S, Merlo A. Droids in disarray: detecting frame confusion in hybrid Android apps. In: IFIP Annual Conference on Data and Applications Security and Privacy; 2019. p. 121–39.
Cen L, Gates CS, Si L, Li N. A probabilistic discriminative model for android malware detection with decompiled source code. IEEE Trans. Dependable Secure Comput. 2014;12(4):400–12.
Chen X, Zhu S. DroidJust: automated functionality-aware privacy leakage analysis for Android applications. In: Proceedings of the 8th ACM Conference on Security & Privacy in Wireless and Mobile Networks; 2015. p. 1–12.
Chen KZ, Johnson NM, D’Silva V, Dai S, MacNamara K, Magrino TR, Wu EX, Rinard M, Song DX. Contextual policy enforcement in android applications with permission event graphs. In: NDSS; 2013. p. 234.
Chen CM, Lin JM, Lai GH. Detecting mobile application malicious behaviors based on data flow of source code. In: 2014 International Conference on Trustworthy Systems and their Applications; 2014a. p. 1–6.
Chen K, Liu P, Zhang Y. Achieving accuracy and scalability simultaneously in detecting application clones on android markets. In: Proceedings of the 36th International Conference on Software Engineering; 2014b. p. 175–86.
Chen S, Xue M, Tang Z, Xu L, Zhu H. Stormdroid: a streaminglized machine learning-based system for detecting android malware. In: Proceedings of the 11th ACM on Asia Conference on Computer and Communications Security; 2016. p. 377–88.
Chen L, Hou S, Ye Y. Securedroid: enhancing security of machine learning-based detection against adversarial android malware attacks. In: Proceedings of the 33rd Annual Computer Security Applications Conference; 2017a. p. 362–72.
Chen H, Leung HF, Han B, Su J. Automatic privacy leakage detection for massive android apps via a novel hybrid approach. In: International Conference on Communications (ICC); 2017b. p. 1–7.
Choi K, Chang BM. A type and effect system for activation flow of components in Android programs. Inf. Process. Lett. 2014;114(11):620–7.
Chua TW, Tan DJ, Thing VL. Accurate specification for robust detection of malicious behavior in mobile environments. In: European Symposium on Research in Computer Security; 2015. p. 355–75.
Chuang HY, Wang SD. Machine learning based hybrid behavior models for Android malware analysis. In: International Conference on Software Quality, Reliability and Security; 2015. p. 201–6.
Citation chaining in Google Scholar and PubMed, 2020. Available from: https://canvas.seattlecentral.edu/courses/1252744/pages/citation-chaining-in-google-scholar-and-pubmed#/.
Cortesi A, Ferrara P, Pistoia M, Tripp O. Datacentric semantics for verification of privacy policy compliance by mobile applications. In: International Workshop on Verification, Model Checking, and Abstract Interpretation pp.; 2015. p. 61–79.
Coulter R, Han QL, Pan L, Zhang J, Xiang Y. Code analysis for intelligent cyber systems: a data-driven approach. Inf. Sci. 2020.
Denis Cr ˘aciunescu, The layers of the Android security model, 2020, Available from: https://proandroiddev.com/the-layers-of-the-android-security-model-90f471015ae6/
Crussell J, Gibler C, Chen H. Andarwin: scalable detection of semantically similar android applications. In: European Symposium on Research in Computer Security; 2013. p. 182–99.
Cui X, Wang J, Hui LC, Xie Z, Zeng T, Yiu SM. Wechecker: efficient and precise detection of privilege escalation vulnerabilities in android apps. In: Proceedings of the 8th ACM Conference on Security & Privacy in Wireless and Mobile Networks; 2015. p. 1–12.
Dai P, Pan Z, Li Y. In: 2018 3rd Joint International Information Technology, Mechanical and Electronic Engineering Conference (JIMEC 2018). Review of researching on dynamic taint analysis technique. Atlantis Press; 2018.
Darki A, Chuang CY, Faloutsos M, Qian Z, Yin H. Rare: a systematic augmented router emulation for malware analysis. In: International Conference on Passive and Active Network Measurement; 2018. p. 60–72.
De Lorenzo A, Martinelli F, Medvet E, Mercaldo F, Santone A. Visualizing the outcome of dynamic analysis of Android malware with VizMal. J. Inf. Secur. Appl. 2020;50.
Degu A. Android application memory and energy performance: systematic literature review. IOSR J. Comput. Eng. 2019;21(3):20–32.
dex2jar, 2020. Available: https://code.google.com/p/dex2jar/.
Duan Y, Zhang M, Bhaskar AV, Yin H, Pan X, Li T, Wang X, Wang X. In: NDSS. Things you may not know about Android (un) packers: a systematic study based on whole-system emulation; 2018.
Egele M, Brumley D, Fratantonio Y, Kruegel C. An empirical study of cryptographic misuse in android applications. In: Proceedings of the 2013 ACM SIGSAC conference on Computer & Communications Security; 2013. p. 73–84.
Enck W, Gilbert P, Han S, Tendulkar V, Chun BG, Cox LP, Jung J, McDaniel P, Sheth AN. TaintDroid: an information-flow tracking system for realtime privacy monitoring on smartphones. ACM Trans. Comput. Syst. (TOCS) 2014;32(2):1–29.
Ernst MD, Just R, Millstein S, Dietl W, Pernsteiner S, Roesner F, Koscher K, Barros PB, Bhoraskar R, Han S, Vines P. Collaborative verification of information flow for a high-assurance app store. In: Proceedings of the ACM SIGSAC Conference on Computer and Communications Security; 2014. p. 1092–104.
Ernst MD. Static and dynamic analysis: synergy and duality. In: WODA 2003: ICSE Workshop on Dynamic Analysis; 2003. p. 24–7.
Evolution of the Mobile Phone, 2020. Available from: https://www.tigermobiles.com/evolution/#start/.
Fadadu F, Handa A, Kumar N, Shukla SK. Evading API call sequence based malware classifiers. In: International Conference on Information and Communications Security; 2019. p. 18–33.
Fang K, Yan G. Emulation-instrumented fuzz testing of 4G/LTE Android mobile devices guided by reinforcement learning. In: European Symposium on Research in Computer Security; 2018. p. 20–40.
Faruki P, Bharmal A, Laxmi V, Ganmoor V, Gaur MS, Conti M, Rajarajan M. Android security: a survey of issues, malware penetration, and defenses. IEEE Commun. Surv. Tutor. 2014;17(2):998–1022.
Faruki P, Bhandari S, Laxmi V, Gaur M, Conti M. Droidanalyst: synergic app framework for static and dynamic app analysis. In: Recent Advances in Computational Intelligence in Defense and Security; 2016. p. 519–52.
Feng Y, Anand S, Dillig I, Aiken A. Apposcopy: Semantics-based detection of android malware through static analysis. In: Proceedings of the 22nd ACM SIGSOFT International Symposium on Foundations of Software Engineering; 2014. p. 576–87.
Fink, S. and Dolby, J., 2012. WALA-The TJ Watson libraries for analysis.
Firdaus A, Anuar NB, Karim A, Ab Razak MF. Discovering optimal features using static analysis and a genetic search based method for Android malware detection. Front. Inf. Technol. Electron. Eng. 2018;19(6):712–36.
Gajrani J, Agarwal U, Laxmi V, Bezawada B, Gaur MS, Tripathi M, Zemmari A. EspyDroid+: precise reflection analysis of android apps. Comput. Secur. 2020;90.
#metrics/.
Gordon MI, Kim D, Perkins JH, Gilham L, Nguyen N, Rinard MC. Information flow analysis of android applications in droidsafe, 15; 2015. p. 110.
Graa M, Boulahia NC, Cuppens F, Cavalliy A. Protection against code obfuscation attacks based on control dependencies in Android Systems. In: Eighth International Conference on Software Security and Reliability-Companion; 2014. p. 149–57.
Graa M, Cuppens-Boulahia N, Cuppens F, Lanet JL, Moussaileb R. Detection of side channel attacks based on data tainting in android systems. In: IFIP International Conference on ICT Systems Security and Privacy Protection; 2017. p. 205–18.
Guo C, Zhang J, Yan J, Zhang Z, Zhang Y. Characterizing and detecting resource leaks in Android applications. In: 28th International Conference on Automated Software Engineering (ASE); 2013. p. 389–98.
Ham YJ, Lee HW, Lim JD, Kim JN. DroidVulMon –Android based mobile device vulnerability analysis and monitoring system. In: Seventh International Conference on Next Generation Mobile Apps, Services and Technologies; 2013. p. 26–31.
Han X, Olivier B. Interpretable and adversarially-resistant behavioral malware signatures. In: Proceedings of the 35th Annual ACM Symposium on Applied Computing; 2020. p. 1668–77.
Han H, Lim S, Suh K, Park S, Cho SJ, Park M. Enhanced Android malware detection: an SVM-based machine learning approach. In: International Conference on Big Data and Smart Computing (BigComp); 2020. p. 75–81.
Hao S, Li D, Halfond WG, Govindan R. Estimating mobile application energy consumption using program analysis. In: 35th International Conference on Software Engineering (ICSE); 2013a. p. 92–101.
Hao S, Li D, Halfond WG, Govindan R. SIF: a selective instrumentation framework for mobile applications. In: Proceeding of the 11th annual international conference on Mobile systems, applications, and services; 2013b. p. 167–80.
Haris, M., Haddadi, H. and Hui, P., 2014. Privacy leakage in mobile computing: tools, methods, and characteristics. arXiv preprint arXiv:1410.
Hassanshahi B, Jia Y, Yap RH, Saxena P, Liang Z. Web-to-application injection attacks on android: characterization and detection. In: European Symposium on Research in Computer Security; 2015. p. 577–98.
He J, Chen T, Wang P, Wu Z, Yan J. Android multitasking mechanism: formal semantics and static analysis of apps. In: Asian Symposium on Programming Languages and Systems; 2019. p. 291–312.
Heuser S, Nadkarni A, Enck W, Sadeghi AR. {ASM}: a programmable interface for extending android security. In: 23rd {USENIX} Security Symposium ({USENIX} Security 14); 2014. p. 1005–19.
Hoffmann J, Ussath M, Holz T, Spreitzenbarth M. Slicing droids: program slicing for smali code. In: Proceedings of the 28th Annual ACM Symposium on Applied Computing; 2013. p. 1844–51.
Hsien-De Huang T, Kao HY. R2-d2: color-inspired convolutional neural network (CNN)-based android malware detections. In: International Conference on Big Data (Big Data); 2018. p. 2633–42.
Hu W, Tao J, Ma X, Zhou W, Zhao S, Han T. Migdroid: detecting app-repackaging android malware via method invocation graph. In: 23rd International Conference on Computer Communication and Networks (ICCCN); 2014. p. 1–7.
Huang J, Zhang X, Tan L, Wang P, Liang B. Asdroid: detecting stealthy behaviors in android applications by user interface and program behavior contradiction. In: Proceedings of the 36th International Conference on Software Engineering; 2014. p. 1036–46.
Huang W, Dong Y, Milanova A, Dolby J. Scalable and precise taint analysis for android. In: Proceedings of the 2015 International Symposium on Software Testing and Analysis; 2015a. p. 106–17.
Huang H, Chen K, Ren C, Liu P, Zhu S, Wu D. Towards discovering and understanding unexpected hazards in tailoring antivirus software for android. In: Proceedings of the 10th ACM Symposium on Information, Computer and Communications Security; 2015b. p. 7–18.
Jensen CS, Prasad MR, Møller A. Automated testing with targeted event sequence generation. In: Proceedings of the 2013 International Symposium on Software Testing and Analysis; 2013. p. 67–77.
Jiang YZX, Xuxian Z. Detecting passive content leaks and pollution in android applications. Proceedings of the 20th Network and Distributed System Security Symposium (NDSS), 2013.
Jiang L, Zhuang Y. Detect storage vulnerability of user-input privacy in Android applications with static and dynamic analysis. In: International Conference on Cloud Computing and Security; 2017. p. 280–91.
Jiang H, Yang H, Qin S, Su Z, Zhang J, Yan J. Detecting energy bugs in Android apps using static analysis. In: International Conference on Formal Engineering Methods; 2017. p. 192–208.
Kabakus AT. What static analysis can utmost offer for Android malware detection. Inf. Technol. Control 2019;48(2):235–49.
Karim I, Cicala F, Hussain SR, Chowdhury O, Bertino E. Opening Pandora’s box through ATFuzzer: dynamic analysis of AT interface for Android smartphones. In: Proceedings of the 35th Annual Computer Security Applications Conference; 2019. p. 529–43.
Kitchenham B, Brereton P. A systematic review of systematic review process research in software engineering. Inf. Softw. Technol. 2013;55(12):2049–75.
Lam P, Bodden E, Lhoták O, Hendren L. The Soot framework for Java program analysis: a retrospective, 15; 2011. p. 35.
Li D, Hao S, Halfond WG, Govindan R. Calculating source line level energy information for android applications. In: Proceedings of the 2013 International Symposium on Software Testing and Analysis; 2013. p. 78–89.
Li D, Tran AH, Halfond WG. Making web applications more energy efficient for OLED smartphones. In: Proceedings of the 36th International Conference on Software Engineering; 2014. p. 527–38.
# 28
# c o m p u t e r s & s e c u r i t y
Octeau D, McDaniel P, Jha S, Bartel A, Bodden E, Klein J, Le Traon Y. Effective inter-component communication mapping in android: an essential step towards holistic security analysis. In: 22nd {USENIX} Security Symposium ({USENIX} Security 13); 2013. p. 543–58.
Octeau D, Luchaup D, Dering M, Jha S, McDaniel P. Composite constant propagation: application to android inter-component communication analysis, 1; 2015. p. 77–88.
Octeau D, Jha S, Dering M, McDaniel P, Bartel A, Li L, Klein J, Le Traon Y. Combining static analysis with probabilistic models to enable market-scale android inter-component analysis. In: Proceedings of the 43rd Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages; 2016. p. 469–84.
Pan L, Cui B, Yan J, Ma X, Yan J, Zhang J. Androlic: an extensible flow, context, object, field, and path-sensitive static analysis framework for Android. In: Proceedings of the 28th ACM SIGSOFT International Symposium on Software Testing and Analysis; 2019. p. 394–7.
Pang Y, Xue X, Wang H. Predicting vulnerable software components through deep neural network. In: Proceedings of the 2017 International Conference on Deep Learning Technologies; 2017. p. 6–10.
Poeplau S, Fratantonio Y, Bianchi A, Kruegel C, Vigna G. Execute this! analyzing unsafe and malicious dynamic code loading in android applications, 14; 2014. p. 23–6.
Qu Z, Alam S, Chen Y, Zhou X, Hong W, Riley R. Dydroid: measuring dynamic code loading and its security implications in android applications. In: 47th Annual IEEE/IFIP International Conference on Dependable Systems and Networks (DSN); 2017. p. 415–26.
Rashidi B, Fung CJ. A survey of Android security threats and defenses. J. Wirel. Mob. Networks Ubiquitous Comput. Dependable Appl. 2015;6(3):3–35.
Rasthofer S, Asrar I, Huber S, Bodden E. How current android malware seeks to evade automated code analysis. In: IFIP International Conference on Information Security Theory and Practice; 2015. p. 187–202.
Rastogi V, Chen Y, Enck W. AppsPlayground: automatic security analysis of smartphone applications. In: Proceedings of the third ACM conference on Data and application security and privacy; 2013. p. 209–20.
Ravitch T, Creswick ER, Tomb A, Foltzer A, Elliott T, Casburn L. Multi-app security analysis with fuse: Statically detecting android app collusion. In: Proceedings of the 4th Program Protection and Reverse Engineering Workshop; 2014. p. 1–10.
Rocha BP, Conti M, Etalle S, Crispo B. Hybrid static-runtime information flow and declassification enforcement. IEEE Trans. Inf. Forensics Secur. 2013;8(8):1294–305.
Rountev A, Yan D. Static reference analysis for GUI objects in Android software. In: Proceedings of Annual IEEE/ACM International Symposium on Code Generation and Optimization; 2014. p. 143–53.
Ryan S, Corizzo R, Kiringa I, Japkowicz N. Deep learning versus conventional learning in data streams with concept drifts. In: 2019 18th IEEE International Conference On Machine Learning And Applications (ICMLA); 2019. p. 1306–13.
Sadeghi A, Bagheri H, Garcia J, Malek S. A taxonomy and qualitative comparison of program analysis techniques for security assessment of android software. IEEE Trans. Softw. Eng. 2016;43(6):492–530.
Safi G, Shahbazian A, Halfond WG, Medvidovic N. Detecting event anomalies in event-based systems. In: Proceedings of the 2015 10th Joint Meeting on Foundations of Software Engineering; 2015. p. 25–37.
Sbîrlea D, Burke MG, Guarnieri S, Pistoia M, Sarkar V. Automatic detection of inter-application permission leaks in Android applications. IBM J. Res. Dev. 2013;57(6):10–11.
Schütte J, Titze D, De Fuentes JM. Appcaulk: data leak prevention by injecting targeted taint tracking into android apps. In: 13th International Conference on Trust, Security and Privacy in Computing and Communications; 2014. p. 370–9.
Schütte J, Fedler R, Titze D. Condroid: Targeted dynamic analysis of android applications. In: 29th International Conference on Advanced Information Networking and Applications; 2015. p. 571–8.
Schoepe D, Balliu M, Piessens F, Sabelfeld A. Let’s face it: faceted values for taint tracking. In: European Symposium on Research in Computer Security; 2016. p. 561–80.
Sexton J, Chudnov A, Naumann DA. Spartan Jester: end-to-end information flow control for hybrid Android applications. In: IEEE Security and Privacy Workshops (SPW); 2017. p. 157–62.
Shankar VG, Somani G, Gaur MS, Laxmi V, Conti M. AndroTaint: an efficient android malware detection framework using dynamic taint analysis. In: ISEA Asia Security and Privacy (ISEASP); 2017. p. 1–13.
Sharif A, Nauman M. Function identification in Android binaries with deep learning. In: 2019 Seventh International Symposium on Computing and Networking (CANDAR); 2019. p. 92–101.
Sharmeen S, Huda S, Abawajy J, Hassan MM. An adaptive framework against android privilege escalation threats using deep learning and semi-supervised approaches. Appl. Soft Comput. 2020;89.
Shen F, Vishnubhotla N, Todarka C, Arora M, Dhandapani B, Lehner EJ, Ko SY, Ziarek L. Information flows as a permission mechanism. In: Proceedings of the 29th ACM/IEEE International Conference on Automated Software Engineering; 2014. p. 515–26.
Shrivastava G, Kumar P, Gupta D, Rodrigues JJ. Privacy issues of android application permissions: a literature review. Trans. Emerg. Telecommun. Technol. 2019:e3773.
Shuai S, Guowei D, Tao G, Tianchang Y, Chenjie S. Modelling analysis and auto-detection of cryptographic misuse in android applications. In: 2014 IEEE 12th International Conference on Dependable, Autonomic and Secure Computing; 2014. p. 75–80.
Song H, Lin D, Zhu S, Wang W, Zhang S. ADS-SA: system for automatically detecting sensitive path of Android applications based on static analysis. In: International Conference on Smart City and Informatization; 2019. p. 309–22.
Sounthiraraj D, Sahs J, Greenwood G, Lin Z, Khan L. Smv-hunter: large scale, automated detection of SSL/TLS man-in-the-middle vulnerabilities in android apps. Proceedings of the 21st Annual Network and Distributed System Security Symposium (NDSS’14), 2014.
Sourav, S., Khulbe, D. and Kapoor, N., 2019. Deep learning based android malware detection framework. arXiv preprint arXiv:1912.
Spreitzenbarth M, Schreck T, Echtler F, Arp D, Hoffmann J. Mobile-Sandbox: combining static and dynamic analysis with machine-learning techniques. Int. J. Inf. Secur. 2015;14(2):141–53.
Statcounter GlobalStats, Mobile operating system market share worldwide, 2020, Available from: https://gs.statcounter.com/os-market-share/mobile/worldwide
Suárez-Tangil G, Dash SK, García-Teodoro P, Camacho J, Cavallaro L. Anomaly-based exploratory analysis and detection of exploits in android mediaserver. IET Inf. Secur. 2018;12(5):404–13.
Suarez-Tangil G, Tapiador JE, Peris-Lopez P, Ribagorda A. Evolution, detection and analysis of malware for smart devices. IEEE Commun. Surv. Tutor. 2013;16(2):961–87.
Sun X, Zhongyang Y, Xin Z, Mao B, Xie L. Detecting code reuse in android applications using component-based control flow graph. In: IFIP International Information Security Conference; 2014. p. 142–55.
# Author Information
Shivi Garg received her M.Tech in Information Security branch from Delhi Technological University, India in 2014. She has been a Ph.D. scholar at Indira Gandhi Delhi Technical University for Women, India since August 2016. Her research interests include Information Security, Android Malware, Machine Learning.
Niyati Baliyan received her Ph.D. in Computer Science and Engineering from Indian Institute of Technology, Roorkee, India in 2016. She has been an Assistant Professor at Department of IT, IGDTUW, since March, 2018. Her research interests include Semantic Web, Knowledge Engineering and Data analytics.