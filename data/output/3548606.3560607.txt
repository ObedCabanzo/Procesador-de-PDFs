# Detecting and Measuring Misconfigured Manifests in Android Apps
Yuqing Yang, Mohamed ElsabaghQuokka*, Chaoshun Zuo
The Ohio State University
yang@osu.edu, melsabagh@quokka.io, zuo@osu.edu
Ryan JohnsonQuokka*, Angelos StavrouQuokka*, Zhiqiang Lin
The Ohio State University
rjohnson@quokka.io, astavrou@quokka.io, zlin@cse.ohio-state.edu
# ABSTRACT
The manifest file of an Android app is crucial for app security as it declares sensitive app configurations, such as access permissions required to access app components. Surprisingly, we noticed a number of widely-used apps (some with over 500 million downloads) containing misconfigurations in their manifest files that can result in severe security issues. This paper presents ManiScope, a tool to automatically detect misconfigurations of manifest files when given an Android APK. The key idea is to build a manifest XML Schema by extracting manifest constraints from the manifest documentation with novel domain-aware NLP techniques and rules, and validate manifest files against the schema to detect misconfigurations. We have implemented ManiScope, with which we have identified 609,428 (33%) misconfigured Android apps out of 1,853,862 apps from Google Play, and 246,658 (35%) misconfigured ones out of 692,106 pre-installed apps from 4,580 Samsung firmwares, respectively. Among them, 84,117 (13%) of misconfigured Google Play apps and 56,611 (22%) of misconfigured pre-installed apps have various security implications including app defrauding, message spoofing, secret data leakage, and component hijacking.
# 1 INTRODUCTION
Android follows a declarative app deployment model where each app is required to declare certain configurations in a file named AndroidManifest.xml in the root directory of an app package (APK) . This app manifest file describes essential information about the app to both Android marketplaces and the Android OS to guarantee proper publishing, installation, and execution of the app on an end-user‚Äôs device. Among many others, an app manifest file declares a variety of important information, including the unique app package name, Android versions compatible with the app, app components and their security and access control settings, permissions requested by the app, and configurations necessary for libraries and features needed by the app.
Due to its importance to app security and reliability, an app manifest file must pass multiple checks by Android app development tools during app development , by Google Play during app publishing , and by the Android runtime during app installation and execution . However, by examining the open-source code and documentation on how Android validates a manifest file, we found that the validation process does not provide systematic coverage of all possible manifest misconfigurations. While we cannot access the source code of Google Play, we notice from this documentation  that Google Play just filters the elements and attributes that are related to feature requirements and compatibility, so as to avoid the app being installed on an incompatible device. Consequently, this can lead to apps with misconfigured manifest files in the wild, creating security issues as witnessed by the disclosed CVEs (e.g., CVE-2017-16835  and CVE-2017-17551 ).
Moreover, our preliminary investigation showed that even some applications associated with world‚Äôs top vendor, e.g., Amazon as shown in Figure 1, may also involve such mistakes, which may lead to concerning purchase replay attack, inflicting losses to the vendor. As such, it is imperative to perform a large-scale study to understand the problem of the misconfigured manifest files, including the history of this misconfiguration problem, the prevalence of misconfiguration in current market, and the impact of these misconfigured manifest in the entire ecosystem, so as to raise the awareness from the community and draw insights to help mitigate this problem. To perform a systematic and automatic check of the misconfiguration, we utilize a standard approach to validate the XML files with XSD schema. To generate the XSD schema, we leverage the official documentation of Android manifest file, which is provided by Google because it is the only source and standard for developer‚Äôs reference when creating manifest files. Putting it all together, we develop a systematic approach to validate the manifest files.
Permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page. Copyrights for components of this work owned by others than ACM must be honored. Abstracting with credit is permitted. To copy otherwise, or republish, to post on servers or to redistribute to lists, requires prior specific permission and/or a fee. Request permissions from permissions@acm.org.
CCS ‚Äô22, November 7‚Äì11, 2022, Los Angeles, CA, USA ¬© 2022 Association for Computing Machinery. ACM ISBN 978-1-4503-9450-5/22/11. . . $15 https://doi.org/10/3548606
# CCS ‚Äô22, November 7‚Äì11, 2022, Los Angeles, CA, USA
# Yuqing Yang et al.
# ManiScope, an NLP-based context-aware analysis tool to identify the manifest entities and their constraints from the documentation, and then generate the XSD for the validation.
We have implemented ManiScope and tested it with 1,853,862 Android apps collected from Google Play between January 2020 and May 2020, and 692,106 pre-installed apps from 4,580 Samsung firmwares (which were released between September 2011 and January 2020) collected from SamMobile . Our investigation revealed a worrying situation: for Google Play apps, ManiScope detected 265,028 misconfigured elements in 230,330 apps and 718,207 misconfigured attributes in 428,440 apps (in total 609,428 unique misconfigured apps). For the pre-installed apps, ManiScope detected 1,731,451 misconfigured elements in 152,046 apps and 386,346 misconfigured attributes in 114,494 apps (in total 246,658 unique misconfigured apps). These results indicate a concerning prevalence of manifest misconfigurations across mobile apps, and these problems can date back to the very early Android version (as early as Android 2+). Moreover, we found that 84,117 (13%) of misconfigured Google Play apps and 56,611 (22%) of misconfigured pre-installed apps could have various security issues, ranging from component hijacking, data leakage, and app crashes, among others.
# Contributions.
- We present ManiScope, a novel and open-source tool that is able to extract manifest constraints from the Android documentation, build a manifest XML Schema, and detect misconfigurations in Android app manifests.
- We propose novel domain- and context-aware NLP techniques to extract manifest constraints from the documentation and handle ambiguities and incomplete sentences in the natural language texts of the documentation.
- We present a large-scale study on over 2 million apps and detected that about a third of these apps contain misconfigurations. We provide an analysis of the prevalence, history and the security threats of these misconfigurations and their root causes.
# 2 PRELIMINARIES
# 2 Android App Manifest File
An Android app is packaged as an archive file (APK) that contains app code, assets, certificates, along with an app manifest file called AndroidManifest.xml, which is an XML file that specifies app components (the building blocks of an app, such as activity and receiver), permissions, and various configurations needed for the proper execution of the app . When installing an app, the Android PackageParser configures the app‚Äôs metadata and runtime settings based on the configurations defined in the app‚Äôs AndroidManifest.xml .
As illustrated in Figure 1, app manifest files are composed of XML elements. Each element has a start and an end tag, can have a number of attributes (e.g., attribute android:name at line 5 that sets the name of the receiver element), and can contain other nested elements. The elements are organized in a tree structure where a child element can belong to only one parent element (e.g., the <intent-filter> element at line 6 is nested in its parent element <receiver>).
01 &lt;manifest package="com.example.app"...&gt;
02  ...
03  &lt;application ...&gt;
04  ...
05   &lt;receiver android:name="com.amazon.*"&gt;
06    &lt;intent-filter&gt;
07     &lt;action
08      android:name="com.amazon.*.NOTIFY"
09      android:permission="com.amazon.*.Permission.NOTIFY"&gt;
11     &lt;/action&gt;
12    &lt;/intent-filter&gt;
13   &lt;/receiver&gt;
14  ...
15  &lt;/application&gt;                      01
16  ...
17 &lt;/manifest&gt;
# 2 Misconfigurations in Manifest Files
The structure of a manifest XML tree specifies the relative positions of the manifest elements, though it does not enforce any particular occurrence constraints. Elements and attributes in an Android app manifest file can be required or optional, and some elements can also occur multiple times. For example, according to the Android Manifest Documentation , an <action> element must occur at least once inside an <intent-filter> parent element.
When developing Android apps, developers have to manually configure app manifest files, though there are some tools to partially automate some of the configurations. Such manual configurations can certainly introduce errors, as evidenced by the example in Figure 1 in which the android:permission attribute, which is supposed to declare the permission required to access the <receiver> component, is incorrectly placed in the <action> element instead of <receiver>. As a result, the receiver component is left unprotected at runtime, allowing arbitrary apps to access and invoke its functionality.
To avoid misconfigurations, developers must clearly understand the XML Schema of app manifest files, i.e., the correct structure and constraints governing elements and attributes in a manifest file. In general, an XML Schema describes three classes of requirements , violating any of which causes misconfiguration: (1) Manifest vocabulary and structure, describing what the valid elements and attributes are and where exactly they can be placed. (2) Occurrence constraints dictating how many times an element or an attribute can appear. (3) Valid attribute values and their data types. Misconfigurations resulting from violating these requirements can be classified based on their root causes into the following categories:
- Misplaced elements and attributes, which can be caused by (1) an element exceeding the upper bound of an occurrence (e.g., can only appear once but appeared multiple times), or (2) an element placed in an unexpected parent (e.g., if <action> element has an invalid parent <receiver>), or (3) an attribute declared inside a wrong element (e.g., android:permission in Figure 1).
- Absent elements and attributes, which occurs when a required element or attribute is missing, i.e., violating its lower bound occurrence constraint.
# Detecting and Measuring Misconfigured Manifests in Android Apps
CCS ‚Äô22, November 7‚Äì11, 2022, Los Angeles, CA, USA
&lt;xs:element name="intent-filter"&gt;
&lt;xs:complexType mixed="true"&gt;
&lt;xs:sequence&gt;
&lt;xs:element ref="action" minOccurs="1" /&gt;
&lt;xs:element ref="category" /&gt;
&lt;xs:element ref="data" /&gt;
&lt;/xs:sequence&gt;
&lt;xs:attribute name="autoVerify" type="xs:string"/&gt;
...
&lt;/xs:complexType&gt;
&lt;/xs:element&gt;
&lt;xs:element name="action"&gt;
&lt;xs:complexType mixed="true"&gt;
&lt;xs:sequence&gt;
&lt;/xs:sequence&gt;
&lt;xs:attribute name="name" type="xs:string"/&gt;
...
&lt;/xs:complexType&gt;
&lt;/xs:element&gt;
- Unexpected elements and attributes, which can be caused by an element or attribute that does not appear in the valid manifest vocabulary, e.g., an undefined &lt;foo&gt; element or a misspelled element in the app manifest file.
- Wrong attribute values, which can be caused by an attribute value that does not satisfy the required data types or allowed data values for the attribute, e.g., value true or false is misspelled for a Boolean type.
Note that a misplaced element or attribute could also be categorized as absent. For instance, if &lt;action&gt; is misplaced inside &lt;data&gt;, which is required by &lt;intent-filter&gt;, it is identified as missing under &lt;intent-filter&gt; and misplaced under &lt;data&gt;.
# 2 Approaches for Validating Manifest Files
App manifest files must be validated to ensure their correctness. In fact, Google provides a number of tools for this purpose. In particular, at development time, Android Studio checks the manifest XML tree for the absence of some critical elements and attributes . During the publishing phase, Google Play checks the app manifest file and applies filters on special compatibility elements (e.g., &lt;compatible-screen&gt;) to decide which devices are compatible with an app . At installation time, the Android PackageParser parses the app manifest file in the APK, checks for required elements, and configures the app runtime accordingly .
A systematic and well-known approach to validate a manifest XML file is through the use of a corresponding XML Schema file that defines the constraints on the structure and content of the XML file. However, by checking the source code of AOSP , we did not find any XML Schema for app manifest files. Instead we found that AOSP uses hand-rolled code to validate manifest files . We found that while AOSP validates all manifest attribute values and their data types , it uses ad-hoc constraints to validate the manifest structure itself (e.g., only checking for occurrence of certain elements and attributes). These hardcoded checks result in incomplete coverage since hand-rolling a complete XML validator that can capture all possible cases of misoccurrences is an exhaustive and error-prone task. As a result, many apps end up on the market with critical misconfigurations, as shown in Figure 1.
Therefore, to systematically validate app manifest files, we need to construct the XML Schema for Android app manifests and then perform the validation using the schema file. In particular, we need to know both the structure and occurrence constraints of elements and attributes of an Android manifest file, where the structure refers to the specific child and parent elements at each particular position of the XML tree and their corresponding attributes, and occurrence constraints refer to the upper and lower bounds of the occurrences of a child element in the tree, i.e., whether it is optional or required and how many times it can appear under the same parent.
After obtaining the structures and occurrence constraints of XML elements and attributes, various XML Schema languages, such as Document Type Definition (DTD) , Relax-NG , Schematron , and XML Schema Definition (XSD) , can be used to develop a specification using these structures and constraints to validate XML files. XSD is the most popular one among these schema languages since it is also written in XML, offers a strong set of specification facilities, and is widely supported by XML parsing packages for many programming languages . XSD supports various features that can be used to directly describe the correct structure and constraints of Android manifest elements and attributes: it can declare valid child elements and attributes of each element, minimum and maximum occurrence of elements, and whether an attribute is required or optional, and so on. An example of an XSD file is shown in Figure 2. All the tag names in XSD files begin with common prefix xs: since they all belong to the XML Schema (XS) namespace. Manifest elements such as &lt;intent-filter&gt; are declared one-by-one using &lt;xs:element&gt;. It can be noticed that an element is an &lt;xs:complexType&gt; if it contains both child elements and attributes. Child elements are then specified inside &lt;xs:sequence&gt; as &lt;xs:element&gt; references, and their number of occurrences are specified using the minOccur and maxOccur attributes. Similarly, valid attributes are specified in &lt;xs:attribute&gt; schema elements. For a full treatment of XSD, we refer interested readers to XSD definition .
# 3 OVERVIEW
The goal of this study is to understand the prevalence, history and security impact of the misconfiguration of Android manifest files. As such, we need to first generate the validation schema for the manifest files. To do so, an intuitive approach is to extract manifest constraints by analyzing the documentation as it is the official guide used by app developers to develop manifest files. Unfortunately, this is still non-trivial, requiring overcoming multiple key challenges as discussed in the following.
# 3 Challenges
C1: Identifying Manifest-Related Documentation Pages. To automatically extract constraints from the documentation, the first challenge is to identify the documentation pages relevant to app manifest files. Currently, there are over 1,000 HTML pages in the latest version of the Android documentation, and they specify constraints not only related to developing Android apps and configuring manifest files, but also to other XML files such as the Android resource XML file, which share the similar structure as the manifest documentation. As such, we need to avoid capturing descriptions.
# ¬ß4 Structured Sections
# ¬ß4 Positional Constraints
# Positional Constraints
# Scheme Generator
# Manifest Schema (XSD)
# ¬ß4 Validation Results
# Android Documentation
# Document Collector
# Free-form Descriptions
# Entity Recognizer
# Candidate Constraints
# Constraint Filter
# App ManifestFile
# Quantitative Constraint Extractor
in every documentation page; otherwise, a large amount of constraints irrelevant to manifest file configuration may be erroneously extracted.
# C2: Handling Ambiguity and Incompleteness in Manifest Descriptions.
It is challenging for an automated system to deal with ambiguities in the descriptions of manifest elements and attributes since they are written in free-form text. Compared with prior NLP-based document mining techniques (e.g., ), we need to perform more complex tasks because we need to not only identify manifest entities referred to in a sentence and determine their relationships (parent or child), applicable positional and quantitative constraints (see ¬ß2), but also translate them to valid XSD.
Fortunately, we find that sentences discussing manifest elements and attributes have common structures. First, sentences describing how to configure manifest entities are mostly imperative sentences that use modal verbs, whereas descriptions specifying maximal occurrences use numerical words to emphasize that an element is unique (e.g., ‚Äòthere is only one...‚Äô). Second, we find that the subjects and objects of complete sentences refer to the parent and child elements respectively. For example, in sentence ‚ÄòAn <intent-filter> element must contain one or more <action> elements‚Äô, <action> is the current element and <intent-filter> is its parent. Although in some contexts, the parent element may be omitted for brevity (e.g., ‚ÄòThe name must be specified‚Äô), the overall structure of subject‚Äìverb‚Äìobject (SVO) remains.
# C3: Performing Context-Aware and Domain-Guided Parsing.
Since sentences in the documentation may omit parent elements for brevity, there may be relevant manifest constraints not captured by the above two sentence structures. In addition, specifications irrelevant to manifest constraints may be mistakenly identified as manifest constraints when they use sentences with SVO structure. Therefore, we need to carefully filter out irrelevant sentences by reasoning about the context in which a sentence occurs and also using the domain-knowledge extracted to guide the filtering.
Interestingly, we noticed that the structural information in the manifest documentation can help build domain-knowledge and identify sentence contexts. Specifically, (1) the omitted entities are often in a structure context. For example, there is a sentence in the documentation for <activity> ‚ÄòThe name must be specified‚Äô, the omitted <activity> is exactly the name of the documentation. (2) The element and attribute names in the titles of each section (such as contained in) yields a dictionary as well as the structure of manifest-related entities, which can be used to build the domain knowledge and filter out the irrelevant and misplaced ones.
The Document Collector traverses the documentation pages by starting from the documentation page of the root element <manifest>, then recursively visiting the documentation pages of each child element.
# 4 DETAILED DESIGN
The workflow of ManiScope is shown in Figure 3. At a high level, it contains five key components: Document Collector (¬ß4), Positional Constraint Extractor (¬ß4), Quantitative Constraint Extractor (¬ß4), Scheme Generator (¬ß4), and finally Manifest Validator (¬ß4). In this section, we present the detailed design of these components.
# 4 Document Collector
As described in C1, we need to automatically collect the documentations related to the manifest file, and extract the structured sections and descriptions for positional and quantitative constraint extraction, respectively. To avoid overly capturing the irrelevant elements and attributes when only using the structure of a document to determine whether it is related to an app manifest, we use a recursive top-down traversal algorithm to identify the attributes and elements related to manifest descriptions.
# Detecting and Measuring Misconfigured Manifests in Android Apps
CCS ‚Äô22, November 7‚Äì11, 2022, Los Angeles, CA, USA
# 4 Positional Constraint Extractor
Given the collected manifest documentation pages, our Positional Constraint Extractor parses each documentation page and extracts child elements under ‚Äòcan contain‚Äô and ‚Äòmust contain‚Äô sections and attributes under attributes sections, respectively. These child elements and attributes are used to construct positional constraints, i.e., valid child elements and attributes for each parent element. For example, when parsing the document example in Figure 4, there is an android:name in the attributes section; therefore, we infer that <action> can have a child attribute of android:name. We also infer that the <action> element has no child elements because there is neither ‚Äòcan contain‚Äô nor ‚Äòmust contain‚Äô sections in its documentation page. When all the positional constraints are extracted, the parser generates a dictionary of all of the names of valid elements and attributes, which is used for filtering out non-manifest related constraints that may be mistakenly identified by the NLP parser. In addition, the parser also extracts descriptions of elements under the descriptions section, and attributes under each attribute name, which are required to extract quantitative constraints as described next.
# 4 Quantitative Constraint Extractor
Since the quantitative constraints are located in descriptions, our Quantitative Constraint Extractor uses NLP techniques to extract these constraints from free-form sentences in the descriptions. However, these natural language sentences are usually ambiguous and incomplete. To deal with the challenges of complex sentences (C2) and improve extraction precision (C3), we design two sub-components: (1) Entity Recognizer (¬ß4) to identify manifest entities (i.e., elements and attributes) and handle ambiguities, and (2) Constraint Filter (¬ß4) to filter out non-manifest related constraints.
# 4 Entity Recognizer
As discussed in C2, to extract constraints from free-form sentences, we need to extract manifest entities, their relationships, and handle missing references. To illustrate these challenges, we present two sentences in Figure 5 with a normal voice (containing nsubj dependency) and a passive voice (containing nsubjpass dependency). The first sentence is written in normal voice, and it suggests that there is a minimum constraint for the child element <action> in the parent element <intent-filter>. We observe that these sentences often appear in Subject-Verb-Object structure. For instance, the subject phrase could be ‚ÄòAn <intent-filter> element‚Äô, and the object phrase could be ‚Äòone or more <action> elements‚Äô. Therefore, we can extract the parent and child entity from the subject phrase and child phrase, respectively. However, since these phrases still contain complex structures such as modifiers and conjectures, we still need to locate the exact word such as <intent-filter> from these phrases, and to handle sentences where object phrases are omitted (e.g., ‚ÄòThe name must be specified‚Äô). To this end, we extract this information by first (ùëñ) recognizing sentence dependencies using a Finite State Machine (FSM), then (ùëñùëñ) handling missing entities using contextual information.
# (I) Recognizing Sentence Dependencies
We observe that in sentences specifying manifest constraints, the parent and child manifest entity appear in subject and object phrases, respectively (e.g., the child element <action> is in the object phrase ‚Äòone <action> element‚Äô). Therefore, our Entity Recognizer extracts the parent and child entity by identifying the dependencies of subject and object phrases.
# CCS ‚Äô22, November 7‚Äì11, 2022, Los Angeles, CA, USA
# Yuqing Yang et al.
# Rules to filter out non-manifest constraints
# Rules to identify misspelled elements and attributes
object phrases until it finds a manifest entity or aborts the parsing must be specified‚Äô appears in the description of the android:name based on the FSM, according to the dependency encountered at each word. We first identify dependencies used in the extraction procedure, including subjects (nsubj, nsubjpass), direct objects (dobj), adjective and noun modifiers (amod, nmod), compound state- ments (compound), and determiners (det) such as the name of an element. We then process these dependencies using the FSM to trace dependencies and identify entities as shown in Figure 6.
In the following, we discuss how our FSM-based approach works using an example of extracting the parent element <intent-filter> from the first sentence in Figure 5. Specifically, as shown in Figure 6, starting at the state verb (points to the word ‚Äòcontain‚Äô in the input as shown in Figure 5), our Entity Recognizer first moves to the noun state (points to word ‚Äòelement‚Äô) based on the state transition of nsubj. Next it moves to adjective state through amod and points to the word ‚Äò<intent-filter>‚Äô. Since there are no more dependencies according to the parsed dependencies illustrated in Figure 5, the Entity Recognizer moves to a special identified state through the none edge. A none edge is a special edge where the state cannot be transferred. As such, when reaching the identified state, we successfully identify the word ‚Äò<intent-filter>‚Äô as a manifest entity. If there is no object phrase in the sentence (e.g., no object phrase after ‚Äòspecified‚Äô in ‚ÄòThe name must be specified‚Äô), the Entity Recognizer regards the corresponding entity as missing and holds its processing until more context information is collected, which will be handled in the next step. If the Entity Recognizer moves to the exit state without reaching the identified state, the tracing process aborts and no constraint is extracted from the sentence.
# Identifying Context Information
Due to the complexity and ambiguity of sentences, there is a chance where manifest-related constraint is not uncovered by our Entity Recognizer. In general, there are two scenarios where a sentence containing manifest constraints may be missed: 1) when the sentence has a missing entity that needs context information to be resolved (e.g., ‚ÄòThe name must be specified‚Äô), and 2) when the identified word does not point to a specific manifest element or attribute (e.g., ‚Äòthis element must be placed inside the <manifest> element‚Äô). Therefore, we need to handle these incomplete and ambiguous manifest entities to avoid missing manifest constraints. To accomplish this, we notice that contextual information in documentation sections and paragraphs provide enough hints for inferring these missing entities.
# Section-level Context
Section-level context refers to information about element and attribute names associated with section titles in the documentation. For example, if the sentence ‚ÄòThe name must be specified‚Äô appears in the description of the android:name attribute in the documentation section for <activity>, we can associate it with the <activity> element as its attribute. When a parent entity is missing, we associate the parent entity with the element name in the title of documentation (because only elements can be parent entities that contain child elements or attributes). When a child entity is missing, we associate the entity with the nearest section context: if the sentence is in the description of an element, we associate the entity with the element name; if it is in an attribute description, we associate it with the attribute name.
At the beginning of paragraphs, we observe that a key sentence is often used to summarize the meaning or functionality of an element or attribute. As such, we utilize this context to improve the constraint extraction by identifying the subject and object from the first sentence of the paragraph (taking sentence dependencies into account). Of course, not all paragraphs provide contextual information in the first sentence, and non-manifest related information may be mistakenly generated. For example, in the documentation of the android:backupAgent attribute under the <application> element, the first sentence says ‚ÄòThe name of the class that implements the application‚Äôs backup agent‚Äô. Although the sentence merely indicates that the attribute is associated with a backup agent class in the source code, the context information may be mistakenly extracted as backupAgent. As a result, when we later encounter the sentence ‚ÄòThe name must be specified‚Äô in the context of android:backupAgent we may identify the child to be ‚Äòname‚Äô but mistakenly identify parent as backupAgent, which is not a valid manifest entity. Hence, it is vital for utilizing the knowledge we extracted about manifest file to filter out these non-manifest constraints to avoid mistakes in the schema.
# Detecting and Measuring Misconfigured Manifests in Android Apps
# CCS ‚Äô22, November 7‚Äì11, 2022, Los Angeles, CA, USA
extract a constraint that says ‚Äò<activity> must be in <activity>‚Äô, which is of course incorrect. As such, we need to filter out these erroneously-extracted constraints, and have designed five rules as shown in Table 1 to filter out the non-manifest constraints at three levels: context, sentence, and word.
# Context Filter
The context filter uses the contextual relationship between the parent and child entity to filter the non-related constraints. There are three rules used by this filter:
- R1: When extracting constraints from broken phrases and sentences that do not contain any manifest entities, our recognizer may treat both the parent and child as missing and extract them from the context. However, there may be sentences completely irrelevant to manifest constraints where both parent and child entities are mistakenly inferred from the context. Hence, we need to focus on sentences containing at least one entity explicitly related to manifest (not inferred from contexts). As such, the constraints where both the parent and the child are extracted from contextual information need to be filtered out.
- R2: As we focus on manifest-related constraints, it is natural that we force all identified parents and children to be contained in the manifest dictionary.
- R3: In addition, we need to further ensure that extracted child is within the valid children list of the extracted parents. For instance, if a parent is action and a child is <intent-filter>, this is not a valid manifest constraint because we know from manifest dictionary that <intent-filter> cannot be a child of <action>.
# Sentence Filter
On top of contextual information, the sentence structures also provide hint for improving the accuracy. Particularly, in rule R4, we use sentence structure to filter sentences with noun (acl) or adverbial clauses (advcl) that voids occurrence constraints in main clauses such as ‚Äòmust have‚Äô. For example, in ‚ÄòYou should always declare this attribute if you want to configure [...]‚Äô, although it seems to be a minimal constraint because this is an imperative sentence with a phrase should always, the adverbial clause ‚Äòif you want to configure‚Äô have voided such minimal requirement because it indicates that the attribute is mandatory only when the developer wants a certain configuration to be effective, whereas it is optional if developers do not want the configuration. Thus, the attribute mentioned in such a sentence is still optional in the manifest file.
# Word Filter
We also utilize words in sentences to reduce errors in occurrence constraint extraction, both for minimal and maximal constraints. On one hand, model verbs that carry strong tone like ‚Äòmust‚Äô have to appear to clearly convey the minimal constraints (‚Äòmust have‚Äô constraints). Therefore, we systematically checked all the modal verbs, and found only must and should conveys such strong tone, whereas other modal verbs can merely convey suggestions or predictions, such as will and may. On the other hand, numerical modifiers, when accompanied by model verb, help identifying maximum constraints. For example, in ‚ÄòOnly one instance of the <compatible-screens> element is allowed in the manifest‚Äô, the manifest entity <compatible-screens> has a numerical modifier one. Therefore, it specifies that the maximum of the element is 1. As such, the word filter filters out non-manifest constraints with a set of modal verb keywords and the numerical modifier dependency nummod (R5).
# 4 Schema Generator
With positional constraints and quantitative constraints extracted and reformed into structured data, we then generate the XSD file for validation. In particular, the positional constraints are transformed by declaring each element with xs:element and then listing its child elements in <xs:element> and attributes in <xs:attribute>, respectively, e.g., in the declaration of <intent-filter> at line 1 in Figure 2, it contains references to child elements such as <action> at line 4, and attributes such as android:autoVerify at line 8 (which is declared at line 11). With the structure of elements and attributes being constructed in XSD, quantitative constraints are generated by setting minOccurs and maxOccurs for elements, and required for attribute (no maxOccurs for attributes as they are unique by nature). For example, the minimum occurrence of <action> is 1, and therefore the minOccurs of <action> is set to 1.
# 4 Manifest Validator
With the generated XSD schema, our Manifest Validator validates an app manifest file by detecting three types of misconfigurations: missing, misplaced, and unexpected. Missing entities are identified when the validator finds an element or attribute missing. Misplaced and misspelled entities, however, are both reported as unexpected keywords, so we need to compare the related element or attribute name with the manifest dictionary. If the entity is a valid manifest name, it is considered misplaced; otherwise, the entity name is misspelled. However, although our validator can detect all the unexpected attributes and elements, they are not always misspelled by developers. For example, compilers may add attributes to provide information of the compiler, and there may be system-only elements and attributes that do not appear in the documentations. As such, to avoid false-positives of identifying these manifest entities as ‚Äúmisspelled‚Äù, we only focus on the following three types of misspelling errors:
- Prefix Errors: This error occurs when developers forget to add or mistakenly add the android: prefix for an attribute (e.g., android:package v.s. package, and android:name v.s. name). To identify this type of error, we remove the android: prefix of the encountered attribute name and compare the attribute name to attributes names in the manifest dictionary (R6).
- Capitalization Errors: A capitalization error occurs when the name of an element or attribute is mistakenly capitalized (e.g., meta-data v.s. Meta-Data). To identify such errors, we match the lowercase prefix-free strings of unexpected names to names in the manifest dictionary (R7 and R8).
- Typos: To identify misspelled element or attribute names (e.g. meta-data v.s. mata-data) we compute the Levenshtein edit distance between an unexpected name and names in the manifest dictionary and check if it is below a certain threshold ùõº, indicating the two words are highly similar (R9 and R10). This threshold must be larger than 0, because no typos will be identified otherwise. However, if this threshold is set too high, it may introduce a large amount of false-positives (e.g., the distance between unexpected name tag and a valid manifest element name data is 3, and hence if the distance is set too high, our tool will regard the tag as a misspelled). To minimize possible false-positives, we set ùõº = 1 as default value for our tool, though it can be configured by users.
# 5 EVALUATION
We have implemented ManiScope in Python. For documentation parsing, we used the lxml  and BeautifulSoup4  libraries. To extract grammatical structures from sentences, we used the NLTK CoreNLP Parser 3 . We evaluated ManiScope on 1 million Android apps downloaded from Google Play between January 2020 and May 2020, and 0 million pre-installed apps collected from 4,580 Samsung firmware (released between September 2011 and January 2020) from SamMobile . We used axmlparserpy  to decode the binary manifest file of each APK into plain-text XML. Our experiments were carried out on a laptop running Ubuntu 18 with 8 GB RAM and an Intel Core i7-8500U CPU. In this section, we first present our evaluation results of schema extraction in ¬ß5. Then, we present our findings with regard to misconfigurations in ¬ß5. Lastly, we provide statistics on security-related misconfigurations in ¬ß5.
# 5 Manifest Constraint Extraction
(I) Extraction Result. We first present how ManiScope performs when provided with the Android documentation. Since it is a fully automated system, it can parse all Android documentation including the historical ones. As such, we tested ManiScope with 20 different Android documentation from Android developers website from the most recent one (after 7) to the oldest available one, namely Android 1, and this result is reported in Table 2. Note that the source code of the historical documentation after 7 is no longer published on public Google repositories, and we obtain the most recent one by directly fetching the online HTML files. In particular, as illustrated in the first row for the most recent documentation, ManiScope collected 26 documentation files related to manifest declaration, and identified in total 348 sections containing 849 paragraphs. When printing them in a format preserved manner (they are organized in a structure), we obtained 190 pages. Among the paragraphs parsed, ManiScope found that 1,326 sentences are written in normal voice and 256 are written in passive voice. Additionally, there are 404 phrases that do not have nominal subjects, either in normal voice or passive voice, which are identified as simple phrases rather than complete sentences. Our Constraint Filter filtered over 90% of non-manifest related constraints through context-filtering rules, and the word filter rules filtered out additional 1% of non-manifest constraints, and eventually it obtained 254 manifest constraints for 28 elements and 125 attributes.
(II) The Evolution of Manifest Documentations. Being able to analyze the historical manifest documentation, we can draw insights such as how they evolved. As such, we quantified such evolution by presenting the difference between two adjacent version of manifest documentations, as shown in Figure 7. First, we observe that the total sentences of manifest constraints, although added or removed, are constantly growing, where the growth rate can range from 0% to over 50%. Second, we notice that during updates, sentences may often be removed with new sentences added, be those removal of deprecated elements or attributes or changes made to descriptions. Interestingly, we also observe that fixing for some typos that eventually caused confusion among developers resulted in some of the misconfigurations, which will be introduced in the correctness evaluation of documentation later.
(III) False Positives (FPs) and False Negatives (FNs) Analysis of Extracted Constraints. The accuracy of the extracted constraints directly determines the accuracy of our misconfiguration detection. Therefore, we must first make sure there is no false positive or false negative. If so, we must correct them. To validate the accuracy of our constraint extraction, we chose the most recent documentation and manually constructed the schema by going over all the documentations. In total, there are 190 pages with 849 paragraphs. To generate the ground truth, we have two security researchers each read the documentations, manually extracted the constraints, wrote the manifest schemas; then the two researchers cross-validated their results to converge. It took 20 days for both researchers to read the documentation, pick out manifest-related documentations, understand contexts, construct schema, and validate them. Then, we compared the manually constructed ground-truth schemas with the automatically generated ones. Among them, we found no false positives but 3 false negatives in constraint generation out of 257 (1%) total schema constraints generated manually. The reason is that the documentation of compatible-screen did.
# Detecting and Measuring Misconfigured Manifests in Android Apps
# CCS ‚Äô22, November 7‚Äì11, 2022, Los Angeles, CA, USA
# Google Play apps
# Pre-installed apps
# Manifest Misconfiguration Detection
# (I) Detection Result.
With the XML schemas reconstructed by ManiScope, we then use them to detect the misconfigurations in most recent apps in Google Play and preinstalled apps in historical firmware, whose overall results are presented in Table 3. Note that the subtotal of apps may not always be equal to the subtotal of misconfigurations as a single app may contain multiple misconfigurations. For Google Play apps, we identified 812,763 misplaced configurations, 5,379 missing configurations, and 165,093 misspelled configurations. For pre-installed apps, we found 301,654 misplaced configurations, 1,730,628 missing configurations, and 85,515 misspelled configurations. We found that manifest misconfigurations are quite prevalent in real-world apps where more than 30% of these apps have at least one misconfiguration.
# Misplaced Configuration.
Most of the misconfigurations among manifest files are misplaced configurations, and ManiScope identified 261,089 misplaced elements and 551,674 misplaced attributes among the 1 million Google Play apps, and 814 misplaced elements and 300,840 misplaced attributes among the 0 million pre-installed apps, as shown in Table 3. We also found that most of the misplaced attributes were related to feature requirements (e.g., android:hardwareAcclerated, android:required), and most of the misplaced elements were frequently used manifest elements (e.g., &lt;meta-data&gt;, &lt;category&gt;), and elements used to configure access permissions (e.g., &lt;permission&gt;, &lt;uses-permission&gt;). Additionally, we observed misconfigurations in extremely popular apps related to icons and themes (e.g., the YouTube app contained a misplaced android:theme attribute), although they are likely to be of no security concern.
# Missing Configuration.
For Google Play apps, missing configurations occur in both elements and attribute. For missing elements, all the 3,900 misconfigurations are related to &lt;action&gt; element in &lt;intent-filter&gt; element. The missing attributes, on the other hand, mainly involved in component name attributes (e.g., android:name) and compatibility attributes (e.g., android:minSdk Version). One possible explanation is that the compiler already examines some critical missing problems and aborts compilation if these misconfigurations exist. However, missing configurations are still concerning since they can result in unavailability of app components and create compatibility issues. For example, if the android:minSdkVersion attribute in the &lt;uses-sdk&gt; element is missing, the system regards the app as compatible with all Android versions, which can cause the app to crash.
For pre-installed apps, although ManiScope did not find any missing attributes, we still identified a large amount of missing &lt;action&gt; (1,673,727 of 1,730,628) and &lt;application&gt; (56,901 of 1,730,628). This could be explained by the difference between pre-installed apps and Google Play apps. For instance, compared with Google Play apps that rely on Intents to perform functionality, most of the pre-installed apps do not need to specify actions for intent-filter, and therefore many &lt;action&gt; elements are not present in &lt;intent-filter&gt; element.
# Misspelled Configuration.
ManiScope detected a large number of misspelled elements and attributes. Among them, we found that there are many more typos than capitalization errors (such as).
# CCS ‚Äô22, November 7‚Äì11, 2022, Los Angeles, CA, USA
# Yuqing Yang et al.
AV: Attack Vector, AC: Access Complexity, C: Confidentiality Impact, I: Integrity Impact, A: Availability Impact, G: Google play app, P: pre-installed app. : None, : Low, : High.
‚àó: For all entries, Privileges Required (PR) is None, User Interaction (UI) is None, and Scope (S) is Unchanged. ‚Ä†: The total downloads of all apps in this category.
Service v.s. service) in misspelled elements. Also, most of the capitalization errors of elements (30 of 39) have the first character capitalized (e.g., Activity). All the 9 capitalization errors in pre-installed apps are the first-character-capitalization problem of <service> (i.e., Service). For typos of elements, most are due to spelling errors (e.g., mata-data v.s. meta-data, which accounts for 5,585 misconfigurations among the 6,446 misconfigurations). Another source of typos comes from a missing hyphen (e.g., intentfilter v.s. intent-filter), and incorrect usage of plural/singular form (e.g., support-screen v.s. support-screens). For pre-installed apps, 472 out of 486 misconfigurations are typo from intent-filter to intent-flter, whereas the rest 14 are plural problems, i.e., permission spelled into permissions. For the top misspelled attributes, we found that missing prefixes are most prevalent (e.g., exported v.s. android:exported).
# (II) FP and FN Analysis of the Detected Misconfigurations
To confirm whether there are any FPs and FNs in the identified misconfigurations, we manually checked random samples of 500 misconfigurations identified by ManiScope from pre-installed and Google Play apps, respectively. Among these 1,000 misconfigurations, we identified zero FNs but 27 FPs (2%). For the false positives, we found that the root cause is due to the typos in the official documentations, which involve two attributes: (1) 5 out of 27 FPs involve android:allowBackup, which was misspelled into android:allowbackup from 4 to 4. As such, ManiScope may only regard android:allowbackup as correct name for a certain version. If a manifest file contains android:allowBackup in application element, which is actually correct, ManiScope identifies it as misspelled instead, resulting in a FP. (2) 22 out of 27 FPs involve resizeableActivity, where the android: prefix is missing from the documentation. As such, ManiScope will identify the correct attribute with prefix as misspelled, resulting in a FP. Interestingly, although the typo of allowBackup is fixed after 4 (but still causing FPs when ManiScope analyzes apps for these versions), the typo of resizeableActivity remained until our responsible disclosure as in July 2021.
The reason why we have zero FN is two-fold. First, identification of positional constraint will not yield FN because we have enforced an allow-list mechanism to detect misplaced manifest entities. As such, the positional constraint will be even stricter than the documentation if we fail to extract any positional constraints. As manifest files containing misplaced element will for sure be inconsistent with the documentation, it will for sure be identified as misplaced by ManiScope. Second, although the quantitative constraint extraction which involves NLP may have FN if we fail to extract some quantitative constraints (thus making the constraint less strict than documentation), we have manually validated with the documentations and found no such a problem.
# 5 Security-Related Misconfigurations
(I) Severity and impacts of the misconfiguration. To determine the security impact of these misconfigurations, we manually checked all of the elements and attributes associated with the misconfigurations to understand their potential security impact. Among them, we identified 2 elements and 13 attributes that could have an impact on security. To rate the security severity of the identified misconfigurations, we categorized them based on their expected severity according to the CVSS (Common Vulnerability Scoring System) 3  scoring metric. This metric is widely used in industry and academia to provide an assigned Common Vulnerabilities and Exposures (CVE) with a severity score. A CVSS score includes six metrics that can be scored with values of high, medium, and low security impact: the attack vector (same network, adjacent network, local, or physical access), access complexity (whether an attacker can expect repeatable success or needs to create certain conditions), confidentiality impact (whether all the exported components are divulged to the attacker), integrity impact (whether the attacker can manipulate the file and data freely), and availability impact (whether it causes a denial of service, or heavy performance losses). The CVSS scores for these 15 misconfigurations are presented in the Score-column of Table 4.
According to the CVSS system, among these 15 misconfigurations that could cause security concerns, 3 of them have high severity, 10 have medium severity, and 2 have low severity. These misconfigurations can result in various security issues, including component hijacking, data leakage, and app crashing. For instance, we can see that apps with a misplaced android:permission attribute are associated with most installs, which may cause purchasing replay attacks. In addition, some misconfigurations (e.g., the data leakage and component hijacking caused by the android:allowBackup
# Detecting and Measuring Misconfigured Manifests in Android Apps
# CCS ‚Äô22, November 7‚Äì11, 2022, Los Angeles, CA, USA
# # Pre-installed apps
Total Downloads: 0‚Äì1K: 1K‚Äì1M: 1M‚Äì1B: 1B+
ProtectionLevel and android:exported attributes) may also affect both thousands of Google Play apps and pre-installed apps. However, compared to Google Play apps, the pre-installed apps make less mistakes, and these pre-installed apps contain significantly less misconfigurations in elements and several attributes (e.g., permission). This might be explained by the limited but essential functionalities of pre-installed apps that make developers avoid using some manifest entities.
# Affected apps with security-related misconfiguration
To further understand the effects of these misconfigurations, we grouped the Google Play apps based on their categories and the pre-installed apps on the firmware versions, as shown in Table 5, where the cell color denotes the scale of total install numbers of affected apps. We notice that most of the misconfigured apps are in the game category, which may be explained by additional system resources required by games to avoid decreased performance or process termination. For pre-installed apps, the misconfigured apps also grow as total amount of apps grow: most of the pre-installed apps are in version 4 to 8, and the problem still exists in recent devices after version 7.
# 6 SECURITY CASE STUDIES
# 6 Component Hijacking
There are several attributes in the manifest file to protect a component from unauthorized access (i.e., component hijacking). However, with misconfigurations of those attributes, the component would have been exposed to attackers. Through a victim‚Äôs component, a malicious app can perform illicit actions such as component hijacking, assume there is a malicious app in the victim‚Äôs phone and this app will attack the app with misconfigured attributes.
Misplaced android:permission attribute. This attribute specifies the permissions required by other apps for component communication, in order to defend against unauthorized access from
# Payment Cloud Msg SMS Msg CCS ‚Äô22, November 7‚Äì11, 2022, Los Angeles, CA, USA
Yuqing Yang et al.
# Table A.
Total downloads: 0‚Äì1K: 1K‚Äì1M: 1M‚Äì1B: 1B+:
Interestingly, on top of the misconfigurations of manifest elements or attributes that are in the documentation, we also detected a wide usage of elements and attributes that are not on the documentation, appearing as unexpected elements/attributes but not identified as typos. This is caused by a set of undocumented manifest entities for applications from Android or OEM producers carrying system signature only, which are designed for testing or privilege-protected configuration. Unfortunately, there are still third-party developers that attempt to use these elements or attributes for configuration, which will eventually be ignored by Android. For instance, among the undocumented elements, we found a particular element called protected-broadcast which appeared in 4,098 apps in total. Due to space limits, we only present the top five categories of each types of components as presented in Table 6(C), which contains 3,261 apps in total. This element is only usable by pre-installed privileged system apps and the Android framework, allowing them to restrict certain broadcast actions to be sent only by the system.
When this element is configured in third-party apps, the Android PackageParser will silently ignore the element and no protection will be granted. This can create a severe vulnerability since any app on the device can send these messages and the receiving app will treat them as though they have been sent by the system.
# 7 DISCUSSION
# 7 Root Causes and Mitigation
One plausible cause of misconfigurations is developer‚Äôs carelessness. Ideally, instead of allowing developers to manually configure the manifests, additional tools should be provided to automate these configurations to reduce potential errors. Second, as evidenced in ¬ß5, the official documentation pages provided by Google contain mistakes (e.g., typos, or missing attributes) which lead to misconfigurations in the manifest files. Finally, similar to many other bugs, code reuse is another root cause. For instance, the Amazon app defrauding case caused by the manifest misconfiguration of the component exposed 9,474 apps to defrauding due to a single misplaced attribute in the official guide on Amazon website that was copied by developers when integrating amazon in-app purchases.
Explicit warnings during validation. The Android operating system currently only triggers error logs on essential problems in app manifest files, and these error logs cannot be easily viewed by the users. Android system could proactively display the warnings to developers and end-users, to help them identify and fix any issues.
Correct and clear documentations. IDE and SDK providers such as Google and Amazon, should provide clear documentation to facilitate developer comprehension for manifest configuration. They also need to ensure that the code snippets provided in their documentation and online resources are correct. Otherwise, defects in the manifest snippets could be propagated to a large number of apps. In addition, they should provide systematic, rigorous validation tools for developers to proactively detect and fix misconfigurations.
# Detecting and Measuring Misconfigured Manifests in Android Apps
CCS ‚Äô22, November 7‚Äì11, 2022, Los Angeles, CA, USA
# Ensuring manifest file correctness.
For app developers, they have to ensure that they understand the configurations correctly, and then leverage automated tools to reduce errors. Meanwhile, they have to be careful copying snippets online as they may contain mistakes that eventually impair the security of their applications.
# 7 Limitations and Future Work
Covering undocumented elements and attributes. Although ManiScope identified all the manifest elements and attributes defined in the official documentation, there may be other elements and attributes defined elsewhere. For instance, developers might define their own attributes and elements. Also, there might be some attributes and elements exclusively for pre-installed apps. Future work could automate the element and attribute extraction from other sources in addition to the official documentation.
Providing more comprehensive case studies. In this paper, we only discussed security-related cases from three categories of misconfigurations. An immediate future work could be performing more comprehensive case studies to measure and identify the potential attacks to raise the attention from community and fix the problems to prevent from exploitation.
# 7 Responsible Disclosure
We have disclosed our findings to Amazon about the issues in apps that use its in-app purchasing SDK, and the incorrect snippets in its documentation and online forum. We have also disclosed all issues involving android:allowBackup attribute and &lt;protected-broadcast&gt; element to developers of impacted apps. Our disclosure of the misconfigurations have been confirmed by various developers, and we were informed that they have fixed or will fix the issue in the future. We had also informed Google about typos in documentations, and the issue was then fixed on July 13th, 2021.
PSCout  adopted code analysis to trace the path of API calls and permission checks, produced a specification of API permission requirements, while Backes et al.  performed analysis of Android permission model across different Android versions. Approaches to derive precise protection by converting CFG  to Access-control flow graph determining necessary protections have also been proposed . Additionally, there have been efforts that looked into insecure components and driver implementations [30, 31, 34, 40, 50‚Äì52]. Compared to these efforts, we systematically investigate novel security issues caused by manifest misconfigurations.
Detecting misconfigurations. On detecting misconfigurations of Android manifest files, Jha et al  identified configuration errors in about 13,000 Android apps using manually constructed constraints. The study, however, relies on predefined rules gathered by manually reading the documentations, and therefore cannot be adopted to generate schema for various versions of documentations for pre-installed app validation. Additionally, the manual approach did not provide a comprehensive coverage of manifest configurations, quantitative constraints, nor potential security issues. To identify potential policy misconfigurations in access control systems, Bauer et al.  applied association rule mining on previously observed accesses to extract statistical patterns (i.e., rules), and then used the rules to detect misconfigurations. Das et al.  proposed to detect inconsistencies of access control updates by correlating access control between group memberships and using statistical techniques to find differences between users. Yuan et al.  discovered user-defined policy violations and inconsistencies among firewall rules. There are a number of other blackbox  and whitebox  approaches to detect misconfigurations. To the best of our knowledge, none of the existing efforts have been used to analyze misconfigurations in Android app manifests.
# 8 RELATED WORK
Extracting information of interest using NLP techniques. As a powerful technique, NLP has been widely used to extract information of interest from free-form texts. For example, to extract constraints from technical documents, Kof et al. and Sadoun et al.  combined lexical, syntactical, and semantic analysis. Korner et al.  integrated part-of-speech tagger, statistic parser, and named entity recognizer to extract the information after splitting the text into chunks, and then validated them with common sense. NLP has also been used to solve various security issues, such as detecting policy declaration and contradictions (e.g., ), bug finding (e.g., ), and cybercrime (e.g., ). All of these efforts also need to solve the ambiguity problem. Various approaches have been proposed, by adopting data mining , developing deep learning models , or using crowd-sourcing approaches to manually identify ontologies . We enrich the state-of-the-art with NLP techniques to extract XSD from documentations.
Android security analysis. Numerous prior efforts on Android security have mainly focused on investigating and identifying security threats in Android apps including requesting excessive permissions, component hijacking, and insecure driver implementations. For instance, for analyzing permission issues in Android systems,
# 9 CONCLUSION
We have presented ManiScope, a tool to automatically construct Android app manifest schema from the official documentation and detect misconfigurations in app manifest files. ManiScope employs novel domain-aware NLP parsing and pruning techniques that allow it to accurately capture positional and quantitative constraints on manifest elements and attributes. We have tested ManiScope with 1,853,862 Google Play apps and 692,106 preinstalled apps, with which ManiScope identified 609,428 misconfigured Google Play apps and 246,658 misconfigured preinstalled apps, respectively. We provided an in-depth analysis and measurement of the security threats posed by these misconfigurations, together with case studies to show their potential impacts.
#parseVerifier. (Accessed on 2021-01-12).
6. 2021. Android Studio linter. https://developer.android.com/studio/write/lint. (Accessed on 2021-01-18).
7. 2021. Apache Xerces. https://en.wikipedia.org/wiki/Apache_Xerces. (Accessed on 2021-01-18).
8. 2021. The attributes used in AndroidManifest.xml. https://cs.android.com/android/platform/superproject/+/master:frameworks/base/core/res/res/values/attrs_manifest.xml. (Accessed on 2021-01-18).
9. 2021. BeautifulSoup Parser. https://lxml.de/elementsoup.html. (Accessed on 2021-01-18).
10. 2021. CVSS v3 Calculator. https://nvd.nist.gov/vuln-metrics/cvss/v3-calculator. (Accessed on 2021-01-18).
11. 2021. Filters on Google Play. https://developer.android.com/google/play/filters. (Accessed on 2021-01-18).
12. 2021. Introduction to DTD. https://www.w3schools.com/xml/xml_dtd_intro.asp. (Accessed on 2021-01-18).
13. 2021. An Introduction to Schematron. https://www.xml.com/pub/a/2003/11/12/schematron.html.
14. 2021. lxml - XML and HTML with Python. https://lxml.de/. (Accessed on 2021-01-18).
15. 2021. Purchasing Listener doesn‚Äôt get called. https://forums.developer.amazon.com/questions/16519/purchasinglistener-doesnt-get-called.html. (Accessed on 2021-01-18).
16. 2021. Python AxmlParser. https://github.com/antitree/AxmlParserPY. (Accessed on 2021-01-18).
17. 2021. Relax NG home page. https://relaxng.org/. (Accessed on 2021-01-18).
18. 2021. SamMobile - Your authority on all things Samsung. https://www.sammobile.com/. (Accessed on 2021-05-30).
19. 2021. Schema - W3C. https://www.w3.org/standards/xml/schema.
20. 2021. View & restrict your app‚Äôs compatible devices | Play Console Help. https://support.google.com/googleplay/android-developer/answer/7353455?hl=en. (Accessed on 2021-01-18).
21. 2021. XML Schema Languages. https://en.wikipedia.org/wiki/XML_schema#Languages. (Accessed on 2021-01-18).
22. Benjamin Andow, Samin Yaseer Mahmud, Wenyu Wang, Justin Whitaker, William Enck, Bradley Reaves, Kapil Singh, and Tao Xie. 2019. PolicyLint: Investigating Internal Privacy Policy Contradictions on Google Play. In 28th USENIX Security Symposium, USENIX Security 2019, Santa Clara, CA, USA, August 14-16, 2019.
23. Kathy Wain Yee Au, Yi Fan Zhou, Zhen Huang, and David Lie. 2012. PScout: analyzing the Android permission specification. In the ACM Conference on Computer and Communications Security, CCS‚Äô12, 2012. ACM.
24. Michael Backes, Sven Bugiel, Erik Derr, Patrick D. McDaniel, Damien Octeau, and Sebastian Weisgerber. 2016. On Demystifying the Android Application Framework: Re-Visiting Android Permission Specification Analysis. In 25th USENIX Security Symposium, USENIX Security 16, Austin, TX, USA, August 10-12, 2016.
25. Lujo Bauer, Scott Garriss, and Michael K. Reiter. 2011. Detecting and resolving policy misconfigurations in access-control systems. ACM Trans. Inf. Syst. Secur. 14, 1 (2011), 2:1‚Äì2:28.
26. Steven Bird, Ewan Klein, and Edward Loper. 2009. Natural language processing with Python: analyzing text with the natural language toolkit. O‚ÄôReilly Media.
27. Yi Chen, Luyi Xing, Yue Qin, Xiaojing Liao, XiaoFeng Wang, Kai Chen, and Wei Zou. 2019. Devils in the Guidance: Predicting Logic Vulnerabilities in Payment Syndication Services through Automated Documentation Analysis. In 28th USENIX Security Symposium, USENIX Security 2019, Santa Clara, CA, USA, August 14-16, 2019. USENIX Association.
28. Tathagata Das, Ranjita Bhagwan, and Prasad Naldurg. 2010. Baaz: A System for Detecting Access Control Misconfigurations. In 19th USENIX Security Symposium, Proceedings. 161‚Äì176.
29. Greg Durrett, Jonathan K Kummerfeld, Taylor Berg-Kirkpatrick, Rebecca S Portnoff, Sadia Afroz, Damon McCoy, Kirill Levchenko, and Vern Paxson. 2017. Identifying products in online cybercrime marketplaces: A dataset for fine-grained domain adaptation. arXiv preprint arXiv:1708 (2017).
30. Mohamed Elsabagh, Ryan Johnson, Angelos Stavrou, Chaoshun Zuo, Qingchuan Zhao, and Zhiqiang Lin. 2020. FIRMSCOPE: Automatic Uncovering of Privilege-Escalation Vulnerabilities in Pre-Installed Apps in Android Firmware. In 29th USENIX Security Symposium (USENIX Security 20). 2379‚Äì2396.
31. Julien Gamba, Mohammed Rashed, Abbas Razaghpanah, Juan Tapiador, and Narseo Vallina-Rodriguez. [n.d.]. An Analysis of Pre-installed Android Software. In 2020 IEEE Symposium on Security and Privacy.
32. Hamza Harkous, Kassem Fawaz, R√©mi Lebret, Florian Schaub, Kang G. Shin, and Karl Aberer. 2018. Polisis: Automated Analysis and Presentation of Privacy Policies Using Deep Learning. In 27th USENIX Security Symposium, USENIX Security 2018.
33. Ajay Kumar Jha, Sunghee Lee, and Woo Jin Lee. 2017. Developer mistakes in writing Android manifests: an empirical study of configuration errors. In Proceedings of the 14th International Conference on Mining Software Repositories, MSR 2017. IEEE Computer Society, 25‚Äì36.
34. Ryan Johnson, Mohamed Elsabagh, Angelos Stavrou, and Jeff Offutt. 2018. Dazed Droids: A Longitudinal Study of Android Inter-App Vulnerabilities. In Proceedings of the 2018 on Asia Conference on Computer and Communications Security. ACM.
35. Lorenzo Keller, Prasang Upadhyaya, and George Candea. 2008. ConfErr: A tool for assessing resilience to human configuration errors. In The 38th Annual IEEE/IFIP International Conference on Dependable Systems and Networks, DSN 2008, June 24-27, 2008, Anchorage, Alaska, USA, Proceedings. IEEE Computer Society.
36. Leonid Kof. 2005. Natural Language Processing: Mature Enough for Requirements Documents Analysis?. In 10th International Conference on Applications of Natural Language to Information Systems, NLDB 2005, Proceedings. Springer.
37. Sven J. K√∂rner and Mathias Landh√§u√üer. 2010. Semantic Enriching of Natural Language Texts with Automatic Thematic Role Annotation. In 15th International Conference on Applications of Natural Language to Information Systems, NLDB 2010, Proceedings. Springer.
38. Yeonjoon Lee, Xueqiang Wang, Kwangwuk Lee, Xiaojing Liao, XiaoFeng Wang, Tongxin Li, and Xianghang Mi. 2019. Understanding iOS-based Crowdturfing Through Hidden UI Analysis. In 28th USENIX Security Symposium (USENIX Security 19). 765‚Äì781.
39. Xiaojing Liao, Kan Yuan, XiaoFeng Wang, Zhongyu Pei, Hao Yang, Jianjun Chen, Haixin Duan, Kun Du, Eihal Alowaisheq, Sumayah Alrwais, et al. 2016. Seeking nonsense, looking for trouble: Efficient promotional-infection detection through semantic inconsistency search. In 2016 IEEE Symposium on Security and Privacy (SP). IEEE, 707‚Äì723.
40. Long Lu, Zhichun Li, Zhenyu Wu, Wenke Lee, and Guofei Jiang. 2012. CHEX: statically vetting Android apps for component hijacking vulnerabilities. In the ACM Conference on Computer and Communications Security, CCS‚Äô12, Raleigh, NC, USA, October 16-18, 2012. ACM.
41. Rebecca S Portnoff, Sadia Afroz, Greg Durrett, Jonathan K Kummerfeld, Taylor Berg-Kirkpatrick, Damon McCoy, Kirill Levchenko, and Vern Paxson. 2017. Tools for automated analysis of cybercriminal markets. In Proceedings of the 26th International Conference on World Wide Web. 657‚Äì666.
42. Driss Sadoun, Catherine Dubois, Yacine Ghamri-Doudane, and Brigitte Grau. 2013. From Natural Language Requirements to Formal Specification Using an Ontology. In 25th IEEE International Conference on Tools with Artificial Intelligence, ICTAI 2013, Herndon, VA, USA, November 4-6, 2013. IEEE Computer Society.
43. Rocky Slavin, Xiaoyin Wang, Mitra Bokaei Hosseini, James Hester, Ram Krishnan, Jaspreet Bhatia, Travis D. Breaux, and Jianwei Niu. 2016. Toward a framework for detecting privacy policy violations in Android application code. In Proceedings of the 38th International Conference on Software Engineering, ICSE 2016, Austin, TX, USA, May 14-22, 2016. ACM.
44. John W. Stamey and Ryan A. Rossi. 2009. Automatically identifying relations in privacy policies. In Proceedings of the 27th Annual International Conference on Design of Communication, SIGDOC 2009. ACM.
45. Henry S Thompson, Noah Mendelsohn, D Beech, and M Maloney. 2009. W3C XML schema definition language (XSD) 1 part 1: Structures. The World Wide Web Consortium (W3C), W3C Working Draft Dec 3 (2009).
46. Peng Wang, Xianghang Mi, Xiaojing Liao, XiaoFeng Wang, Kan Yuan, Feng Qian, and Raheem A Beyah. 2018. Game of Missuggestions: Semantic Analysis of Search-Autocomplete Manipulations. In NDSS.
47. Xiaoyin Wang, Xue Qin, Mitra Bokaei Hosseini, Rocky Slavin, Travis D. Breaux, and Jianwei Niu. 2018. GUILeak: tracing privacy policy claims on user input data for Android applications. In Proceedings of the 40th International Conference on Software Engineering, ICSE 2018. ACM.
48. Tianyin Xu, Jiaqi Zhang, Peng Huang, Jing Zheng, Tianwei Sheng, Ding Yuan, Yuanyuan Zhou, and Shankar Pasupathy. 2013. Do not blame users for misconfigurations. In 24th Symposium on Operating Systems Principles, SOSP. ACM.
49. Lihua Yuan, Jianning Mai, Zhendong Su, Hao Chen, Chen-Nee Chuah, and Prasant Mohapatra. 2006. FIREMAN: A Toolkit for FIREwall Modeling and ANalysis. In 2006 IEEE Symposium on Security and Privacy (S&P 2006), 21-24 May 2006, Berkeley, California, USA. IEEE Computer Society, 199‚Äì213.
50. Lei Zhang, Zhemin Yang, Yuyu He, Zhenyu Zhang, Zhiyun Qian, Geng Hong, Yuan Zhang, and Min Yang. 2018. Invetter: Locating Insecure Input Validations in Android Services. In Proceedings of the 2018 ACM SIGSAC Conference on Computer and Communications Security (Toronto, Canada) (CCS ‚Äô18). ACM.
51. Qingchuan Zhao, Chaoshun Zuo, Brendan Dolan-Gavitt, Giancarlo Pellegrino, and Zhiqiang Lin. 2020. Automatic Uncovering of Hidden Behaviors From Input.
# Detecting and Measuring Misconfigured Manifests in Android Apps
# CCS ‚Äô22, November 7‚Äì11, 2022, Los Angeles, CA, USA
# Validation in Mobile Apps
In Proceedings of the 2020 IEEE Symposium on Security and Privacy. San Francisco, CA.