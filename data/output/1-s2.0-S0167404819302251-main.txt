# Computers & Security 90 (2020) 101688
# Contents lists available at ScienceDirect
# Computers & Security
# ELSEVIER
# journal homepage: www.elsevier.com/locate/cose
# EspyDroid+: Precise reflection analysis of android apps
# Jyoti Gajrania,∗, Umang Agarwalb, Vijay Laxmia, Bruhadeshwar Bezawadac, Manoj Singh Gaur d, Meenakshi Tripathia, Akka Zemmarie
a Malaviya National Institute of Technology Jaipur (MNIT Jaipur), India
b Govt. Engineering College Ajmer, India
c Mahindra École Centrale, Hyderabad, India
d Indian Institute of Technology Jammu, India
e LaBRI, Bordeaux INP, University of Bordeaux, CNRS, France
# Article history:
Received 8 August 2019
Revised 18 November 2019
Accepted 13 December 2019
Available online 13 December 2019
# Keywords:
Instrumentation, Reflection, Run-time, Malware, Static, Dynamic, Privacy leaks, Android
# Abstract
Malicious smartphone apps use reflection APIs to exfiltrate user data and steal personal information. These malware use reflection along with parameter obfuscation and encryption to evade detection by static analysis. Dynamic analysis is a possible approach to detect such run-time malicious behavior. However, dynamic analysis of a software, usually, results in the exploration of a large, potentially exponential, number of program branches. Many of these program paths are not useful to analyze the reflection APIs, and significantly affect the efficiency of the dynamic analysis. In this paper, we propose a hybrid analysis approach named EspyDroid+1 that overcomes the drawbacks of static analysis in analyzing the obfuscated and run-time dependent parameters of reflection APIs. EspyDroid+ incorporates Reflection Guided Static Slicing (RGSS), an efficient approach to deal with exploration of large number of program paths by pruning irrelevant program paths and ensures that the resultant paths get executed during the subsequent dynamic analysis. We observed that EspyDroid+ successfully removed 59% of the total paths on a test dataset consisting of 660 apps without any loss of semantics. We conclude that EspyDroid+ is effective, fast, and scalable in uncovering reflection API induced privacy leaks.
# 1. Introduction
Since the release of Android, research community and anti-virus industry are continually discovering and reporting various security issues of Android apps. Manual analysis of malware is not feasible looking at the growth rate of Android apps. Each day, malware authors are incorporating various advanced techniques in malicious apps to hinder their analysis by automated tools. Reflection and run-time binding are few primary techniques that are popularly used by malware authors. Andrubis  is an online research approach that analyses uploaded apps and from the analysis of apps collected over a span of four years, they reported that reflection is employed by 57% of Android malware samples. Ripple , a static analysis based Reflection analysis approach for Android apps, analyzed 6141 Android malware apps collected from the VirusShare project (VirusShare, 0 0 0 0) and reported that 48% of these apps use reflection. DroidRA , a static analysis based approach for analysis of Reflection in Android apps, showed that 76% of analyzed 438 apps use reflection in primary app code. These statistics motivated us towards developing a more precise and scalable solution for analyzing reflection APIs.
Static analysis based approaches have several inherent limitations. First, static analysis misses many reflection targets as malware authors typically combine reflection with run-time dependent code. This includes run-time dependency of parameters of reflection APIs using array indices, substrings, encryption, polymorphism, etc. . Second, static analysis based on type inference like Ripple  generates many false positives, leading to low precision.
Dynamic analysis based solutions improve analysis in such situations by executing the app to observe its behavior. The downside, however, is that there exist a large number of paths to be explored during dynamic analysis . Therefore, dynamic analysis suffers from the path explosion challenge and thus, cannot achieve the desired coverage.
To address the limitations of static and dynamic analysis, a few hybrid approaches  have been described in literature. Tamiflex  is...
∗ Corresponding author.
E-mail addresses: 2014rcp9542@mnit.ac.in (J. Gajrani), vlaxmi@mnit.ac.in (V. Laxmi), bru@mechyd.ac.in (B. Bezawada), manoj.gaur@iitjammu.ac.in (M.S. Gaur), mtripathi.cse@mnit.ac.in (M. Tripathi), zemmari@labri.fr (A. Zemmari).
1 An early version of this paper was published in Gajrani et al. (2017a)
https://doi.org/10/j.cose
0167-4048/© 2019 Elsevier Ltd. All rights reserved.
# J. Gajrani, U. Agarwal and V. Laxmi et al. / Computers & Security 90 (2020) 101688
an approach for reflection analysis of Java programs. However, Tamiflex misses many true targets, which were behind complex GUI operations. MIRROR  is an optimized solution compared to Tamiflex for analyzing Java programs. MIRROR reduces the paths to be executed by identifying relevant paths. However, the traditional Java language specific solutions are not directly applicable for Android due to asynchronous and event-driven paradigm with multiple-entry points for app and callbacks. Specifically, in Android complex GUI operations like sending email, SMS, providing appropriate text-inputs are too complex to simulate during dynamic analysis. Not only the simulation of events but also the correct ordering of these operations is a crucial task. As a result of these factors, pure dynamic analysis does not scale well for large apps having many GUI elements.
Android provides Monkey (UI/Application Exerciser Monkey, 0 0 0 0) as part of Android SDK, which generates the specified number of random events during testing. The limitations of Monkey are: 1) the events are random and hence, may not be relevant for the testing objective, 2) many repeated events are generated, 3) a low probability of generating the correct text-input, and 4) no guaranteed coverage. To provide a better solution, compared to Monkey (UI/Application Exerciser Monkey, 0 0 0 0), more advanced automated GUI exploration approaches for Android  have been proposed. Most of these approaches still have about 30% to 60% code coverage. This implies that, at most, only 60% of the requisite reflection APIs can be analyzed by dynamic analysis if these APIs are distributed uniformly. Therefore, dynamic analysis based on the exploration of a complete app does not guarantee that the desired APIs will be executed.
Further, almost all dynamic analysis based tools fail in the cases where the application depends on user inputs. Approaches such as  work on providing relevant text inputs; however, it is challenging to simulate correct text-inputs like user-name, password, email-id, phone number, etc., even at the initialization for many apps. Trimdroid  is an approach for GUI testing of Android applications using an enhanced combinatorial method of providing input-data along with automated program analysis, and formal specifications. However, Trimdroid requires source code to analyze the dependencies between GUI elements and further analysis, which restricts its applicability to analysis of malware and store apps.
This paper proposes, EspyDroid+, an approach that provides a right balance of recall and precision. Precision is the fraction of correctly analyzed targets within all identified targets of reflection APIs. Low precision implies many incorrect targets identified. Recall is the fraction of correctly analyzed targets within all targets including missed. Low recall implies that many targets are missed.
EspyDroid+ unites dynamic analysis with a static analysis technique of our own design: Reflection Guided Static Slicing (RGSS), to reduce the number of program paths to be explored. RGSS generates an optimized app by removing all components that do not lead to the invocation of any reflection call. Further, we maximize the likelihood of execution of the reflection APIs by rewriting various conditional statements through bytecode instrumentation. The aim is to force the reflection APIs to execute at run-time. The main contributions of this paper are as follows:
- We propose EspyDroid+, a hybrid analysis approach for reflection analysis in Android apps to resolve obfuscated reflection calls precisely in comparison to the static state-of-the-art approaches.
- EspyDroid+ uses RGSS, an enhanced static analysis approach customized to prune the app. Specifically, prior to the dynamic analysis, RGSS generates a sliced app by eliminating irrelevant paths having no reflection APIs. This reduces the impact of the state-space explosion problem faced by the ensuing dynamic analysis phase of EspyDroid+.
- We assess EspyDroid+ on 660 apps collected from diverse sources including benchmark dataset F-Droid (Free and Open Source App Repository, 0 0 0 0), VirusTotal dataset, malicious apps from malgenome project (Jiang and Zhou, 2012), dataset developed Canadian Institute for Cybersecurity (CIC) Canadian Institute for Cybersecurity, and state-of-the-art dataset . RGSS prunes 59% of total paths on the test dataset of 660 apps. EspyDroid+ outperforms other approaches in terms of both recall and precision.
Organization. The paper is organized as follows: Section 2 provides a motivating example and the challenges in state-of-the-art research. We discuss our proposed solution, EspyDroid+ in Section 3. Section 4 presents implementation details and evaluation results. Section 5 describes few limitations of our proposal. We describe related work in Section 6 and conclude in Section 7 outlining possible future work.
# 2. Background
Android provides four types of components as basic blocks of the app: Activity, service, content provider and broadcast receiver. Activity facilitates Graphical User Interface (GUI) and runs in foreground; all the background tasks are implemented as part of service; content provider manages data storage and access through files, SQLite databases, Internet, etc.; broadcast receiver registers itself for one or more events, and is notified by Android OS on the occurrence of these events. Java classes in the app, which do not extend any of these four components, are termed non-component classes. The interaction among components of same or different apps is through inter-component communication (ICC) feature called Intent. The communication APIs use Intent objects, which specify the target component explicitly or implicitly with the help of intent-filters. All the components are declared in the app’s manifest file AndroidManifest.xml. There is no single entry point of a component unlike the main() function in Java. Instead, Android supports defining callback methods (e.g., onClick(), onBackPressed(), etc.) in components and invocation of these is by the Android system based on the event. Android also provides another way of storing/retrieving data in the form of a key-value pair called SharedPreferences.
# 2. A representative example
This section presents an example app that illustrates how run-time binding of reflection APIs limits state-of-the-art static analysis approaches. Through this representative example app, we illustrate the challenges in dynamic analysis. The code base of the example app is a representative of obfuscation techniques used by various malware families and some real-world apps.
The developed app consists of mainly eight components including six activity components, namely: Home (A), Instructions (B), Play (E), Rating (F), ScoreBoard (H), Settings (I), one service component named MyServices (C), one receiver component named SMS_rec (D), and two simple Java classes, named read (G) and write (J) as shown in Fig. 1. The figure includes the code of only the relevant components to save space and the complete app code is available at https://github.com/jyotigajrani/EspyDroidPlus. The paper uses alphabets in brackets for referring particular class and X.n refers to the nth line of class X in Fig. 1.
The example reads the IMEI number of the host device and leaks the same to the system log using reflection APIs and obfuscation of parameters. Primarily, activities A and B contain reflection.
# J. Gajrani, U. Agarwal and V. Laxmi et al. / Computers & Security 90 (2020) 101688
# App Components
public void onStart(Bundle savedInstanceState) {
@Override
Home SMS tec
startActivity(new Intent(this, Instructions.class));
}
# B. Instructions
@Override
MyServices G. read
public void onResume(Intent intent) {
if (Build.BRAND.equals("generic")) {
System.exit(0);
} else {
String meth = string forName(clz);
getIntent().getStringExtra(eclz_);
new String(Base64.decodeBase64(em));
}
}
MyPrefsFile Class getMethod(eth).invoke();
public static String 'MyPrefsFile' Class forName(clz).getMethod(meth).invoke();
public static SharedPreferences getSharedPreferences(SF);
public void write_sf() {
SharedPreferences.Editor sf = getSharedPreferences("MyPrefsFile", MODE_PRIVATE).edit();
sf.putString("imei", getDeviceId());
sf.apply();
}
# API calls
The execution of A leads to invocation of onCreate() lifecycle method of component B, which calls the method stored in variable meth of class clz (B-B). However, the values are bound to this variable at run-time due to encoded values. This obscures both string  and type inference  based static reflection analysis approaches in computing targets. The method actually calls the write_sf() method of class J. The write_sf() method reads the IMEI of the device by invoking getDeviceID() method and stores it in SharedPreferences "MyPrefsFile" (J-J). On return from B to A, onResume() life-cycle method of A is called. Execution of A invokes the method through reflection APIs where parameter meth is encoded through Base64 encoding.
# Challenges for Analysis
- Late binding of reflection targets: Android malware families like Obad, FakeNotify use reflection to call sensitive methods and use encrypted method names, which are decrypted at run-time. The encrypted parameters get their actual values only at run-time. Malware families such as Fakeinstaller.AH (Ruiz, Oct 2012) leak private data through the massive use of reflection, which obscure calls to sensitive source and sink APIs. Similarly, the targets of reflection APIs (A) have late binding and this thwarts static analysis solutions because of their inability to uncover parameter values in such cases.
- Inter-component communication: In Android, due to the widespread usage of ICC, resolving of a value at any point has a dependency on the execution of code present in another component. This dependency is in terms of the values of global variables declared and initialized in other components, values written in shared preferences, values passed from one component to another in Intent extras, etc. Ripple  illustrates an example of AngryBird app where reflection targets depend on data-flow through Intents. The example of Fig. 1 shows that class name read.java is passed as extra information through the Intent from B to A activity (B).
# Program Slicing
Program slicing is a technique of reducing program in such a way that only those statements and variables that affect the execution of target instruction are computed (called slices) without affecting the program behavior .
However, traditional algorithms for computing instruction level slices using def-use chains  fail for event based environments like Android when execution of any instruction is dependent on many factors like reflection, run-time dependency, etc. SharedPreferences, Intents, GUI events.
Rasthofer et al. (2016) proposed Harvester, an approach for automatically extracting run-time values of parameters of various APIs of interest. Harvester computes instruction-level backward slices starting from the APIs of interest and afterwards executes each of the slice directly independent of its position in the original app which eliminates the need of any GUI interaction. The values of interest (VOIs) such as some class and method names that are dynamically loaded and invoked via reflection are logged at run-time. Harvester is resilient against code obfuscation where the parameters are obfuscated using various ways to hinder static analysis. However, the major limitation of Harvester is that it cannot calculate VOIs in cases of inter component dependency due to the limitation of the highly optimized backward slicing algorithm which is limited within the scope of a single class. One such case is shown in the example of Fig. 1 where the values cannot be inferred by the independent execution of components. The slice computed using instruction-level.
4 J. Gajrani, U. Agarwal and V. Laxmi et al. / Computers & Security 90 (2020) 101688
slicing is for component A is shown in Fig. 3. As seen from A A A the slice, the value of parameter at Line A is coming from Intent, which is not captured in the traditional slice.
- Conditional constraint: Malware families such as Pincer, Basebridge, NickSpy (Jiang and Zhou, 2012) hinder dynamic analysis through various anti-emulation techniques , time-bombs, logic-bombs, and other conditions. These are presented as conditional checks. The example of Fig. 1 adds anti-emulation constraint (A-A) which check value of BRAND. The value is always “generic” or “generic_86” for emulator while for real device, the value depends on brand of device.
- Complex GUI: Malware apps hide malicious code behind complex GUI widgets to hinder analysis by automated tools based on Monkey UI/Application Exerciser Monkey as these are not designed to tackle such complex GUI events. Moreover, providing correct text-input for automated solutions is very challenging.
The above discussion highlights the need for developing approaches that overcome these complex challenges for the ensuring the privacy of Android Apps.
# 2. Problem statement and scope
We are assuming that the app is malicious and developed by attacker. A “Source” is an API that accesses user’s private data, and a “Sink” is an API that potentially leaks this data outside the application. The attacker obfuscates the path from Source to Sink APIs through use of reflection APIs. Further, the attacker is aware of evasive techniques, specifically, reflection with inter-component communication and obfuscation of parameters. Most of the reflection aware static analysis techniques are not able to reveal the leaks.
Dynamic analysis is useful in such scenarios, dynamic analysis must generate the necessary GUI and system events leading to the execution of required malicious behavior during testing to achieve efficiency. Also, the dynamic analysis approach, if applied on apps having a large number of program paths results in non-trivial time of analysis and limited code coverage, which makes it unsuitable for large stores. This poses the requirement of an approach that can reduce the state space of dynamic analysis. The state-of-the-art solution  reduces the space sufficiently but results in loss of information such as data passed between components through inter-component communication.
We aim to design a framework for identifying such hidden leaks with a good balance between state space reduction and accuracy. The key idea is to strengthen dynamic analysis by reducing the state space of Android apps by considering reflection APIs as the target. The target is to support state-of-the-art static analyzers in analyzing otherwise missed leaks without modifying them to improve the recall.
# 3. Proposed solution: EspyDroid+
The main contribution of EspyDroid+ is a better slicing algorithm, which enables more reflective calls to be covered by pruning components not leading to reflective calls, and without any loss of accuracy. This makes EspyDroid+ well suited for large applications. The next important contribution is that, EspyDroid+ added the solution for handling anti-analysis constraints. Moreover, EspyDroid+ can trigger more reflective calls because of the handling of non-UI events/actions. EspyDroid+ can handle reflective calls present in both UI and non-UI components unlike state-of-the-art, which mainly focus on UI components. In summary, our approach helps to achieve scalability, which was otherwise a constraint for dynamic analysis. We discuss these aspects in further detail in this section.
# 3. Reflection guided static slicing
We describe and implement Reflection Guided Static Slicing (RGSS) to prune those components of the app, which are not directly or indirectly relevant for the execution of reflection code during dynamic analysis. Specifically, we aim to prune GUI components.
Intelligent UI Sliced Exploration Instrumented APK Run-time values of reflection targets Reform Reflection APIs by Instrumentation
# J. Gajrani, U. Agarwal and V. Laxmi et al. / Computers & Security 90 (2020) 101688
# Inter-Component Callers (DialDroid Analysis)
We describe a coarse-grained approach of component level slicing, which does not remove any code from any component except breaking links towards components not containing any relevant API. Our aim is not to compute the smallest slices based on instruction-level slicing but in contrast a safe slice to avoid any loss in the computation of target parameters. RGSS includes five steps to construct sliced apk as shown in Fig. 4.
We represent an app as a 5 tuple state diagram (Q, , δ, q0, F), where each state q ∈ Q represents the app’s class and each input event e ∈ () is an instruction whose execution leads to another state. On execution of e, there will be a transition (δ) from one state to another state. The start state q0 is the launcher activity of app that is always unique for any app in Android and defined in the manifest file. EspyDroid+ is implemented on top of Soot , a bytecode analysis and optimization framework. We extract q0 using ProcessManifest final states class provided by Soot. All the states having reflective calls are (F).
We generate a reduced state diagram by eliminating irrelevant transitions and call it Reflection Guided State Diagram (RGSD). We first describe an approach to model standard state diagram from an Android app and then an algorithm designed for generating RGSD from the original state diagram.
# Step 1: Components transition analysis
This step constructs state diagram from app bytecode. We only include the app’s classes as states. In Android, the communication between two components is through ICC methods, which are standard and predefined. A large body of research including IccTA , Epicc, Amandroid , A3E (Azim and Neamtiu, 2013), Dial-Droid  worked on finding ICC links and targets of ICC calls. We found DialDroid the most suitable as it provides the instruction along with ’caller state’ and ’called state’ relation. We leverage DialDroid to extract information of ICC links. DialDroid provides information of communication among all four types of Android components using explicit intents, implicit intents, content providers, call to broadcast receivers. The extracted information of ICC links is used to construct state diagram. Reflection APIs can be part of component classes or simple Java classes.
The communication between two non-components is possible through remote procedure calls (RPC). As none of the above tools works on processing RPC calls, we identified RPC links using callgraph and bytecode analysis. We added code for capturing unsupported edges of Thread and AsyncTask in Soot generated callgraph. Similar to ICC, the extracted RPCs are added in the state diagram. Our implementation stores the state diagram as Maps (key-value pairs) having caller component name + method name + (i.e., instruction) as key and callee as value. According to Soot’s terminology, each instruction of Jimple is called unit. The state diagram for example of Fig. 1 is shown in Fig. 5.
# Step 2: Extraction of final states
While processing application classes for the presence of RPC calls from their intermediate code, we also parse reflection APIs and store the result in the form of “CN-MN” where MN is a method of class CN containing reflection APIs. All of Android’s framework classes are excluded while parsing reflection APIs. These classes are the final states (F) of state diagram and given as input to the next step. The reflection APIs are maintained in the configuration file which is the input of this step along with apk. For the example of Fig. 1, this step generates F = {A, B, C, D}.
# Step 3: State Diagram to RGSD conversion
This step is converting State Diagram to RGSD, which means removal of all transitions not relevant to reach the final states. We do not remove any code or class from the app except the irrelevant transitions. Instruction level slicing is not always safe because sometimes the slices do not execute correctly or generate exceptions due to various features of Android as discussed in Section 2. The key idea is to apply depth-first backward traversal from F for finding useful transitions. The complexity of the Algorithm is O(Q + δ), which is the complexity of the backward depth-first traversal.
Algorithm 1 describes this step. The results of previous steps, i.e., state diagram and F are input to this step. The algorithm uses a queue, called processQueue for maintaining the states to be processed. Initially, we add F to processQueue as the backward analysis starts with final states (Line 1). RQ is the list for storing all relevant states such that RQ⊆Q. As all the final states are also relevant.
states, so we add these to RQ (Line 2). Rδ, initialized empty, is the set of all relevant transitions such that Rδ⊆δ (Line 3). The traversal starts with processing initialized processQueue and continues until the queue becomes empty. The empty queue signifies that the processing has finished. The algorithm dequeues one element at a time from the processQueue at a time, stores in CQ and finds its predecessors (Line 6). If the node has predecessors, then all the predecessors that are not already present in the queue, are enqueued to processQueue. This check is done to ensure that loops are not created during the traversal. These predecessors are added to RQ list. All the transitions among each of the predecessors and CQ are relevant transitions, and so these are added to Rδ (Lines 9–15).
# Algorithm 1: State diagram to RGSD.
Input: SD - State Diagram (Output of Step 1), F - Final States (Output of Step 2)
Output: RGSD
/* Analysis of Relevant Transitions */
1. processQueue.enque(F); // processQueue for maintaining states to be processed
2. RQ ← F; // RQ for storing relevant states
3. Rδ ← ∅; // Rδ for storing relevant transitions
4. UnlinkedStates ← ∅;
5. while processQueue.empty() is not TRUE do
6. &nbsp;&nbsp;CQ ← processQueue.deque(); // CQ for storing current state
7. &nbsp;&nbsp;PRE ← Predecessors of CQ;
8. &nbsp;&nbsp;if PRE.size > 0 then
9. &nbsp;&nbsp;&nbsp;&nbsp;for pre ∈ PRE do
10. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if processQueue.contains(pre) is not TRUE then
11. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;processQueue.enque(pre);
12. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RQ.add(pre);
13. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Rδ.add(δ(pre, CQ, unit));
14. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end
15. &nbsp;&nbsp;end
16. end
17. else
18. &nbsp;&nbsp;if CQ != q0 then
19. &nbsp;&nbsp;&nbsp;&nbsp;UnlinkedStates.add(CQ);
20. &nbsp;&nbsp;end
21. end
/* Pruning of Irrelevant Transitions */
1. for each δ in SD do
2. &nbsp;&nbsp;if !δ.in(Rδ) then
3. &nbsp;&nbsp;&nbsp;&nbsp;Remove δ by swapping corresponding unit with NOP;
4. &nbsp;&nbsp;end
5. end
App components like broadcast receivers and services may be invoked based on system events like SMS_RECEIVED, POWER_LESS if the apps register for intent filters for events in manifest files. However, these components may be final states or predecessors of some final states. These components may not have any incoming transition in state diagram as they do not have any call through implicit or explicit Intent. During the path computation, we come across such states, and these are not initial states (q0) either. This implies that there is no path to these states from launcher activity.
We aim not to miss any such paths during dynamic analysis. Therefore, we prepared a separate list, UnlinkedStates containing all such states that do not have any paths from the start state, using inter-procedural analysis within the class using callgraph. The callgraph has caller-callee relation within the class. By root method, we mean the topmost caller of the method that contains.
J. Gajrani, U. Agarwal and V. Laxmi et al. / Computers & Security 90 (2020) 101688
Sr5 &lt;android.os.Build: java Hlang String BRAND&gt;
Sz0 virtualinvoke Sr5.&lt;java lang String: boolean equals(java lang Object)&gt; generic" );
Szo = 1
520I= 0 Sz0
TRUE System exit(0);
FALSE
Sr5 &lt;android.os Build: java lang String BRAND&gt;;
Sz0 virtualinvoke $r5.&lt;java lang String: boolean equals(java Hang Object)&gt; generic_X86");
Jiang, 2012). Such components are called by Android when the event for which the component subscribe occurs. Therefore, the suspicious code present in these components may not execute during dynamic analysis. Android 8 supports 191 different broadcast actions and 26 different service actions. Simulating these large number of events during dynamic analysis is not practical and acceptable. Only the events relevant to app under analysis can be simulated. AppsPlayground  artificially raises few system events like boot completed event by using a fast reboot of VM. However, the approach causes system inconsistencies and it is not possible to simulate all events artificially.
One solution for this is proposed in Dynodroid , which instruments Android SDK for observing the system events registered by app. The instrumented SDK is loaded along with emulator which observes broadcast receivers and system services. Thereafter, the appropriate intent along with random data is serialized and events are triggered by modified Activity Manager tool (am). The modifications are done to add support for all types of arguments, which were missed in original am tool. The principal limitation of DynoDroid  is that for finding system events registered by app and thus the components registering these, SDK modification is required, which is not generic for all versions of Android. In contrast, EspyDroid+ gets the name of these components and corresponding events through previous steps and then instruments the code for sending intent to each of the component class in UnlinkedStates in Jimple. The intent for a specific component is constructed with a specified action and corresponding intent data with valid random values. This data is used in constructing putExtra and putString calls.
The selection of instrumentation point is done based on the type of unlinked component. The intent for receivers and services are added in launcher state while the intent for activity is placed in final state. This is because non-GUI components work in background through launcher without affecting the app’s original functionality. While linking activity may affect the app’s original functionality therefore, we add intent for unlinked activities in final state, which has path from launcher. The preference is given to the final state, which is not having any outgoing transitions to preserve the app’s original flow. However, if no such final state is found then any final state with the least number of outgoing transitions is selected. For the example of Fig. 1, explicit intent is added as shown in Fig. 8 by the dotted arrow from state 1 to state 4. The overall effectiveness of RGSS depends on relevancy of app code with respect to analysis target.
# 3. Intelligent UI exploration
We leverage Intelligent UI exploration module from our earlier work  along with some improvements. The approach is black-box developed by extending the Robotium framework . The exploration time depends on the complexity of app GUI. The average exploration time for the experimental data-set of 40 apps as measured in  was 6 minutes. In comparison, when the same dataset’s
# 8
J. Gajrani, U. Agarwal and V. Laxmi et al. / Computers & Security 90 (2020) 101688
sliced apps by EspyDroid+ were used for testing, the average exploration time reduced to 3 minutes.
In , we compare our earlier Intelligent UI testing approach with Android Monkey in terms of Class, Method, Block, and Line coverage using Emma tool EMMA on 40 open source apps from F-Droid (Free and Open Source App Repository, 0 0 0 0). We selected F-Droid dataset for comparing coverage of dynamic analysis as Emma requires source code of apps undergoing testing. The average coverage on 40 apps in percentage for Class, Method, Block, and Line by Monkey is 55, 47, 33, and 35 (42) while for our approach, the coverage is 58, 50, 42, and 40 (47) which shows improvements of our dynamic analysis over Android Monkey.
We could not compare with most relevant and contemporary dynamic analysis framework Harvester  results on same dataset as Harvester is not available in public domain and the apps are not open source. DROIDPF , another relevant work presented dynamic analysis results in terms of exploration time and property violation and not especially focused on coverage of reflection APIs.
The main objective of this work was to improve precision of dynamic analysis presented in our earlier work . We improve the Intelligent UI Exploration in two ways. First, we do not want app to terminate execution if proper text inputs are not given. Therefore, we propose to generate validation complaint text input e.g., email-id, date, phone number, etc. Instead of generating completely random input, we provide domain specific input by maintaining database of valid inputs corresponding to possible labels/hints available for these inputs in app. Second, we employ error detection and handling module. In earlier works, no consideration was given to UI exploration terminating due to any error encountered in app. This resulted in many prematurely terminated unsuccessful runs in dynamic analysis. We augment a solution to detect errors and start the exploration again taking care that erroneous inputs are not repeated. The widgets which cause abnormal app termination due to invalid input or event, insufficient data etc. during execution are recorded and it is ensured that erroneous views are ignored in subsequent runs. This avoids unnecessary and unsuccessful execution of apps.
From implementation point, we create SharedPreferences for the app under test and store the information of all widgets causing termination in that. The reason of choosing SharedPreferences is because it does not require any permission. The SharedPreferences is created with values initially set to null during first run. Each time before performing any action on any widget, it is confirmed that the widget is not present in the SharedPreferences. Before exploring particular widget, the necessary information to identify that widget is printed to the system logs. If the app terminates with exception then the information from logs is stored to SharedPreferences so that the same can be ignored in next execution. The execution of app starts again with the updated SharedPreferences file.
# 3. Reform reflection APIs
This phase constructs the code statements that use reflection by their semantically equivalent non-reflection way (traditional Java calling) and instrument these in the original app . The automated instrumentation is done in Soot’s intermediate representation Jimple using dynamically obtained parameters. The non-reflection calls are simple Java calls to these methods constructed with the obtained values of corresponding parameters. The instrumented code before reflection call A of activity A is as shown in Listing 1. The instrumentation allows off-the-shelf static analyses tools such as FlowDroid , IC3  to correctly interpret originally obfuscated behaviors, which were missed by these tools while analyzing original apps. The original reflective calls are not removed while instrumenting new calls.
# 4. Implementation and evaluation
RGSS is implemented on top of Soot . Step 1 finds ICC transitions by leveraging DialDroid  which is also based on Soot. We design a parser module to process and store the results of DialDroid as Maps (key-value pairs) having caller component name + method name + (i.e., instruction) as key and callee as value. Both Pruning of Irrelevant Transitions (Step 3) and Constraint Handling (Step 4) use Jimple Transformation Pack (jtp) of Soot during instrumentation. We performed all the evaluation on Intel E5-2420v2 2 GHz processor with 80 GB memory.
We evaluate EspyDroid+ on diverse datasets to avoid any potential discrimination. The first dataset is composed of 13 medium size open source apps downloaded from F-Droid (Free and Open Source App Repository, 0 0 0 0). The reason for choosing this dataset is the availability of app source code, which makes it easier for manual verification purpose. We manually add malicious reflection code, which includes ICC dependency and obfuscation in each app. We obtain ICC communication among components of each app and select any two components (caller-callee) at random having communication. The code for collecting IMEI using reflection APIs and sending this IMEI to callee along with ICC call as parameter is added in caller component. Similarly, the code for receiving of IMEI and leaking it through use of reflection APIs is added in callee component. This approach of adding reflection is based on various samples contributed by us to DroidBench. The second dataset composed of same 17 apps as used by Ripple  on reflection analysis. All the apps are downloaded from Google Play store. The choice to select this dataset is because the apps contain reflection code and we could compare the results. The average app size is 55 MB in this dataset. The apps were quite large as compared to F-Droid dataset and all the apps were having complex GUI, and large number of components, which is a challenge for state-of-the-art. The third dataset is composed of randomly selected samples (2017 and 2018) downloaded from VirusTotal. As the fourth dataset, we choose various families from Malgenome project (Jiang and Zhou, 2012). Specifically, we selected the apps from families that massively use reflection to hide calls to sensitive API methods used for leaking sensitive data. The last dataset is composed of 413 apps which are classified by authors in four categories i.e., SMSMalware, Adware, Scareware, and Ransomware. This dataset is created by the Canadian Institute for Cybersecurity and recently used in (Fallah and Bidgoly, 2019; Lashkari et al., 2017; 2018; Lee and Park, 2019; Taheri et al., 2019).
# J. Gajrani, U. Agarwal and V. Laxmi et al. / Computers & Security 90 (2020) 101688
Performance evaluation of proposed approach RGSS.
Evaluation of dynamic analysis.
VT - VirusTotal, #RLog - Number of reflection calls logged.
responds to a huge reduction in the exploration space of dynamic analysis with same accuracy. This reduction is without loss of any information as our approach does not remove any path leading to desired state. As shown in the last column of Table 1, exploration of sliced apps takes around 1 minute for the average app size of approximately 55 MB while the original apps have quite large exploration time. The automated exploration follows the approach mentioned in . Table 1 - column 7 depicts the number of explicit transitions added by EspyDroid+ for different datasets for improving the coverage of reflective calls. We manually verify the results of Table 1 for F-Droid dataset (opensource) and found that EspyDroid+ is able to log all reflection calls successfully. We used Android emulator having API level 19 for experiments. The apps are instrumented with APIMonitor to report the reflection APIs executed in Logcat. Table 2 shows the results of number of distinct reflection calls logged and exploration time for both original (#RLog (Original)) and sliced app (#RLog (Sliced)) after dynamic analysis module of EspyDroid+. Due to paucity of space, details of nine randomly selected apps have been added. We have added the results of all the 267 apps as the last row of Table 2. As seen from the Table 2, the number of logged reflection APIs is sufficiently higher on sliced apps. Moreover, the exploration time on sliced apps is reduced significantly. The results in Table 2 show that EspyDroid+ has 9% more coverage (Number of reflection calls logged increased from 2684 to 2950) on sliced apps because of conditional rewriting through instrumentation, improved UI exploration, and adding of explicit intents. Table 2 further shows 51% of decrease in analysis time (exploration time reduced from 15,356 seconds to 7486 seconds) due to removal of irrelevant paths. We came across various sensitive run-time operations, such as termination of incoming calls, connecting to Command & Control server, etc., which were hidden through reflection deeply inside app components.
RGSS for representative example of Virustotal dataset.
The app checks whether Internet is available or not and turn on the mobile data in case Internet not available. The app has declared permission of CHANGE_NETWORK_STATE along with other dangerous permissions. The app uses field, method, and class reflection for enabling mobile data and thereafter leaks various information of device like IMEI, Build, release, etc., through Internet. The original app is having 12 states (2 activities, 2 services, 5 receivers, and 3 non-component classes), 12 transitions, and one final states (State 11). Reflective calls were present mainly in one Java class. RGSS reduced the number of transitions to 10 where one of the valuable pruning is the transition between MainActivity to Cgiva Activity (State 1 to State 2 in Fig. 9). As shown in Table 2, the number of reflection calls logged in original app is 0. The dynamic analysis is triggering Cgiva activity and then stopping the analysis. There is receiver boutq which has paths to final state. However, its calling is dependent on system event BOOT_COMPLETED.
3 https://developer.android.com/studio/command-line/logcat
4 0a3e346cce78c22a1e8a6ee92d97e65050bcd92339eda1ee738759446a8b4f4e
10 J. Gajrani, U. Agarwal and V. Laxmi et al. / Computers & Security 90 (2020) 101688
therefore, receiver’s call is added from Launcher activity (dotted line between State 1 and 7). Moreover, the invocation of service aznfeuwcwekw in state 3 is controlled through IF condition which checks the specific value of incoming Intent Extra. EspyDroid+ has successfully rewritten that constraint to make forced invocation of service and able to log all reflection APIs.
# 5. Limitations of EspyDroid+
EspyDroid+ cannot handle hybrid apps that include native code in the app itself not from the Android OS, and JavaScript code. If the ICC links are not statically resolvable by Dialdroid, then component transition analysis would not calculate paths completely. Nonetheless, the success rate, identified links/actual links, of DialDroid is 95% as measured and verified manually on open source apps downloaded from F-Droid Free and Open Source App Repository. DialDroid misses the links to component of fragment Activity type so the transition in state diagram is missed. However, EspyDroid+ adds a direct intent to such missed components. EspyDroid+ instruments the apps for optimization as well for appending non-reflection calls corresponding to reflection calls. Therefore, EspyDroid+ can not analyze the apps which have implemented the mechanism to prevent themselves from being modified or function improperly on being modified. EspyDroid+ will be inefficient in situations where the app contains behavior dependent on specific data inputs which are not removed in RGSS and the desired inputs are not provided by dynamic analysis.
The effectiveness of static reduction depends on whether a large part of the app is irrelevant with respect to the reflection code. However, our approach never prunes a relevant component as it does an over-approximation. We keep all paths towards a relevant component, so if at least, one path leading to target code will be executed, it give at least 1 value of obfuscated parameters of reflection APIs. The over-approximation approach implies that EspyDroid+ never results in loss of information due to slicing with respect to analysis targets.
# 6. Related work
We broadly categorize approaches for reflection analysis of mobile apps in static analysis and dynamic analysis. This section elaborates upon various state-of-the-art solutions under each approach.
# 6. Static analysis
Li et al., proposed DroidRA , which uses string inference for resolving reflection targets in Android apps. DroidRA addresses reflection by solving a constant string propagation problem. However, the approach can resolve class and method names from reflective calls only if these are constants. This limits the approach for targets which are non-constant.
Ripple  further supplemented string inference with type inference for getting reflection targets, which are non-constant and non-null strings but whose variable/object type can be inferred like values read from configuration files or provided from command lines. For a known target method whose receiver object is unknown, it infers the object based on the type of method’s class. However, type inference is limited due to a large number of false positives as many objects/variable may have the same type in a method. This leads to low precision. Second, static analysis based on type inference like Ripple generates many false positives, leading to low precision. Ripple is unable to resolve many reflection targets. The primary reason is attributed to the lack of both string and type information for the reflective targets that are accessed with statically unknown ways like encryption, polymorphism, and reflection. EspyDroid+ prevents false alarms in contrast to Ripple as targets are reported only after actually executing the app. EspyDroid+ has high recall as it can effectively handle obfuscation with the use of dynamic analysis.
Authors in MIRROR  propose hybrid reflection analysis approach for Java applications. The reflection oriented slicing ahead of dynamic analysis increases the code coverage of dynamic analysis significantly with low false reflective targets. However, the approach does not apply to Android due to various reasons like no single entry point, event-oriented execution, dependency between components using different ways as mentioned in Section 2.
# 6. Dynamic/hybrid analysis
Harvester  as described in Section 2 computes highly optimized slices (intra-component slices) and thus will not be able to identify the target of reflection APIs accurately during ICC dependency. EspyDroid+ approach of slicing is peculiar to component level slicing which improves the overall recall. Standard methods of computing the backward slices (Chen and Xu, 2001; Jayaraman et al., 2005) are not practically feasible for platforms like Android.
DROIDPF  is a framework that proposes model checking for identifying sensitive leaks in Android apps. The authors developed executable mock-up Android OS for enabling JPF  to dynamically explore the concrete state spaces of Android apps. Mock-up OS includes programs for generation of user interactions and environmental inputs, which drive the dynamic execution of the apps. However, DROIDPF identifies obfuscated reflection targets only and does not include reformation and instrumentation of equivalent non-reflection APIs in the original app. Also, it is limited by underlying JPF so it can only explore the app if the underlying JPF can explore. The approach is too complex due to the design of mock-up OS. Adding features of new Android releases and associated libraries require the efforts of continuous development of the precise model of mock-up OS for verifying latest apps, which limits the scalability of DROIDPF. DROIDPF is not fully automatic as one of the case is Pincer which is controlled by C&C server. For Pincer, DROIDPF can find malicious behaviors but with manual efforts of analysts by providing data inputs, which satisfy branching conditions. In contrast, EspyDroid+ includes taming conditional behaviors that make it independent of such external events.
StaDyna  focuses on addressing dynamic code loading and reflection using the hybrid approach. The static analysis first constructs call graph of application, then run the app and afterward expands callgraph with additional information captured at run-time. However, evaluation is done only in terms of an increased number of nodes and edges without any focus on privacy leakage. It needs a modified Android OS, which makes its installation and usage difficult. It does not provide a way to directly benefit existing static analyzers, i.e., to support them in performing reflection-aware analyses.
The first version of EspyDroid+ named EspyDroid was presented for uncovering reflection employed with run-time dependency in Android apps in our earlier work . EspyDroid+ has a number of considerable enhancements. First, EspyDroid+ proposes RGSS, a novel slicing approach that strengthens dynamic analysis by pruning irrelevant paths with respect to analysis targets. RGSS models the original app in form of Deterministic Finite Automaton by capturing transitions using intra-component, inter-component, and remote call analysis techniques. As detailed in Section 3, EspyDroid+ proposes an approach for converting RGSD (Reflection Guided State Diagram) from the original state diagram. RGSD prunes all the irrelevant transitions without any loss of accuracy. The results show that
J. Gajrani, U. Agarwal and V. Laxmi et al. / Computers & Security 90 (2020) 101688
# 6. Machine learning
In Android, number of vulnerable and malicious apps are increasing at an alarming rate and due to this, analysis time per app should be as small as possible without any loss of accuracy. Therefore, many authors have proposed machine learning based approaches, especially, deep learning based approaches which may be able to identify vulnerabilities not yet found.
Wang Wei et al.  propose a framework which employs an ensemble of multiple classifiers for detecting malicious apps and also categorizing benign apps. They extract 2,374,340 features from each app and apply Support Vector Machine (SVM) model to assign weights to features based on their effectiveness in distinguishing benign and malicious features. Finally, they used 34,630 top ranked features to perform the detection of malicious apps and the categorization of benign apps. The app undergoes classification by 5 classifiers i.e., SVM, Classification and Regression Tree (CART), Random Forest, Naive Bayes, and KNN algorithms. The final classification is based on the majority of these five classifiers. The authors shown effectiveness of proposed approach by performing evaluation on a large app set of 107,327 benign apps and 8701 malicious apps.
Liu Xing et al.  designed and implemented framework called “Alde”, which discovers privacy leaks caused by analytics libraries. The authors show that even some Google playstore and Chinese market apps leak private information to analytics libraries without users consent allows the owners of these companies to profile and characterize the users. The authors proposed and developed an app “ALManager” which leverages Xposed framework  to hook tracking APIs used by analytics libraries and further control the information to be collected by these.
Android apps have high dimensional feature set which require high training time. Wang et al.  propose to combine deep autoencoder (DAE) with convolutional neural network (CNN) to improve the detection accuracy and reduce the training time. Authors show that with inclusion of DAE, essential features of Android apps are captured efficiently. Further, CNN-S and CNN-P structures are employed and experimental results demonstrate that CNN-S model improves accuracy by 5% compared with Support Vector Machine (SVM) on the dataset of 23,000 apps. The time required for training is reduced by 83% by using DAE-CNN when compared to CNN-S model.
# 7. Conclusion and future work
In this work, we propose EspyDroid+, an automatic reflection analysis approach for Android apps. EspyDroid+ tackles the limitation of static analysis in verifying true targets of reflection by dynamically executing the app. Further, we propose RGSS for reducing the state space of dynamic analysis. We propose an approach to model standard state diagram from an Android app and modeling state diagram into an efficient Reflection Guided State Diagram (RGSD), which is suitable for dynamic analysis of reflection APIs. Instead of exploration of a complete app, dynamic analysis executes the sliced app having paths leading to reflection code. EspyDroid+ is also effective in handling anti-analysis, logic bombs, time bombs, C&C controlled execution, etc. Although, the current focus is on reflection code, it could be easily extended to log parameters of other sensitive sinks similarly. Limiting the number of paths to be explored based on analysis target makes EspyDroid+ an efficient solution for analyzing large real-world Android applications. We applied EspyDroid+ on a collection of 660 apps from diverse sources and showed that EspyDroid+ can significantly reduce the exploration time as the links not relevant to reflection code are broken.
Machine learning based solutions detect any possible malicious activity based on the structure of the app and depend on how good training dataset is. Considering that many zero day vulnerabilities are discovered only after an attack, modeling this vulnerability requires an analysis of effect of attack on vulnerable app and hybrid of static, dynamic, and machine based methods may be more effective than any single analysis technique. Therefore, in future, we further work on hybrid solution combining static, dynamic, and machine learning based methods.
# Declaration of Competing Interest
The authors declare that they have no known competing financial interests or personal relationships that could have appeared to influence the work reported in this paper.
# Author Information
Jyoti Gajrani received the M.Tech. degree in Computer Engineering from the Indian Institute of Technology, Bombay in 2013. She is currently pursuing the Ph.D. degree (Part-time) in computer science with Malaviya National Institute of Technology, Jaipur, under the supervision of Prof. Manoj Singh Gaur from Indian Institute of Technolgy, Jammu and Dr. Meenakshi Tripathi from Malaviya National Institute of Technology, Jaipur. She is working as Assistant Professor (Full-time) in Computer Engineering department at Govt. Engineering College, Ajmer since 2006. Her research interests include the area of security and privacy, with a special emphasis on security in Android.
Umang Agarwal is an undergraduate student at Govt. Engineering College Ajmer. Along with programming, his research interest includes cyber security, malware analysis. He has participated in various hackathons and programming contests conducted at national level. He has also developed Android apps for cultural and sports events in his college.
Dr. Vijay Laxmi received her Master’s in Computer Science and Engg. from Indian Institute of Technology Delhi and Ph.D. from University of Southampton, UK. She has been a faculty in Department of Computer Science and Engineering, Malaviya National Institute of Technology Jaipur, India. Her research interests include Information security, Malware analysis, Security and QoS provisioning in wireless Networks.
Prof. Bruhadeshwar Bezawada has received his B.E. (ECE, Distinction) from Osmania University, India; M.S. (Electrical and Computer Engineering) and PhD from the Dept. of Computer Science and Engineering at Michigan State University, USA. He is currently Professor of Computer Science at Mahindra Ecole Centrale, India. Previously he was an Assistant Professor at the International Institute of Information Technology, India, Visiting Scholar at Nanjing University, China, University Professor (visiting) at K.L. University, India, and Senior Research Associate at Colorado State University, USA. His research interests are in the areas of information security, Internet-of-Things, Cyber-physical systems, cloud computing security and malware analysis. His paper has won the Best Student Paper award at DBSec 2019.
Prof. Manoj Singh Gaur completed his Master’s degree in Computer Science and Engineering from Indian Institute of Science Bangalore, India and Ph.D. from University of Southampton, UK. Prof. Gaur has been a faculty in Department of Computer Science and Engineering, Malaviya National Institute of Technology Jaipur, India and currently Director, IIT Jammu. His research areas include Networks-on-Chip, Computer and network security, Multimedia streaming in wireless networks.
# J. Gajrani, U. Agarwal and V. Laxmi et al. / Computers & Security 90 (2020) 101688
# Dr. Meenakshi Tripathi
Dr. Meenakshi Tripathi is currently an associate professor at Computer Science and Engineering Department, Malaviya National Institute of Technology Jaipur, India. She has been teaching UG and PG courses in the area of mobile computing and wireless communications. Her research interests are in the areas of security, wireless sensor networks and software defined networks. She is also a member of IEEE and ACM.
# Akka Zemmari
Akka Zemmari has received his Ph.D. degree from the University of Bordeaux, France, in 2000. He is an associate professor in computer science since 2001 at University of Bordeaux, France. His research interests include machine and deep learning, randomized algorithms, security and distributed algorithms and systems.