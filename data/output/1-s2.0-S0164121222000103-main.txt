# Taxonomy of security weaknesses in Java and Kotlin Android apps
Alejandro Mazuera-Rozo a,b,∗, Camilo Escobar-Velásquez b, Juan Espitia-Acero b, David Vega-Guzmánb, Catia Trubiani c, Mario Linares-Vásquez b, Gabriele Bavota a
a Università della Svizzera Italiana, Lugano, Switzerland
b Universidad de los Andes, Bogotá, Colombia
c Gran Sasso Science Institute, L’Aquila, Italy
# Article history:
Received 3 March 2021
Received in revised form 14 July 2021
Accepted 20 January 2022
Available online 31 January 2022
# Keywords:
Security
Android
Android is nowadays the most popular operating system in the world, not only in the realm of mobile devices, but also when considering desktop and laptop computers. Such a popularity makes it an attractive target for security attacks, also due to the sensitive information often manipulated by mobile apps. The latter are going through a transition in which the Android ecosystem is moving from the usage of Java as the official language for developing apps, to the adoption of Kotlin as the first choice supported by Google. While previous studies have partially studied security weaknesses affecting Java Android apps, there is no comprehensive empirical investigation studying software security weaknesses affecting Android apps considering (and comparing) the two main languages used for their development, namely Java and Kotlin. We present an empirical study in which we: (i) manually analyze 681 commits including security weaknesses fixed by developers in Java and Kotlin apps, with the goal of defining a taxonomy highlighting the types of software security weaknesses affecting Java and Kotlin Android apps; (ii) survey 43 Android developers to validate and complement our taxonomy. Based on our findings, we propose a list of future actions that could be performed by researchers and practitioners to improve the security of Android apps.
© 2022 The Authors. Published by Elsevier Inc. This is an open access article under the CC BY-NC-ND license (http://creativecommons.org/licenses/by-nc-nd/4/).
# 1. Introduction
Mobile apps and devices are nowadays omnipresent in daily life activities, supporting many crucial tasks (e.g., banking, social networking, etc.) involving the manipulation and storage of sensitive and private data. The usage of mobile operating systems has already exceeded the usage of desktops/laptops operating systems (StatCounter, 2020a,b; Google, 2019a). As a consequence, mobile apps and devices have become a very attractive target for malicious attacks aimed at stealing private and sensitive information from apps/devices and to exploit on-device capabilities such as processing, data collection via sensors, and networking. Also, according to the CVE details portal1 the number of vulnerabilities in the Android operating system has seen a steep growth in the last years, with a total of 2563 reports in 10 years (2009–2019). As a natural reaction to such a rising of vulnerabilities in the mobile ecosystem, original equipment manufactures (OEMs), operating system designers (e.g., Google), researchers, and companies have devoted efforts to improve the security of mobile OSs, devices and apps.
A paramount example is the volume of research focused on detecting vulnerabilities in Android apps (see e.g., Arzt et al., 2014; Li et al., 2015; Sadeghi et al., 2017; Lee et al., 2017; Singleton et al., 2019; You et al., 2016; Bello-Jiménez et al., 2019; Ren et al., 2015; Novak et al., 2015; Gadient et al., 2018). The Android OS and devices have been also investigated in the context of previous studies aimed at categorizing their security weaknesses and exploits (e.g., Huang et al., 2015; Thomas et al., 2015; Cao et al., 2015; Wang et al., 2016; Jimenez et al., 2016; Bagheri et al., 2018; Meng et al., 2018; Mazuera-Rozo et al., 2019). Even datasets with malicious apps have been built (Allix et al., 2016; Zhou and Jiang, 2012).
Still, to the best of our knowledge, there is no comprehensive taxonomy of security weaknesses exhibited in Android apps. With security weaknesses we refer to flaws or gaps in a software that could be exploited to violate its security policy, thus eventually causing a disruption of the confidentiality, integrity, or availability of the system in question. As compared to desktop applications, Android apps may suffer of specific vulnerability types since they (i) run on a mobile device, thus usually collecting a larger amount of information about the user (e.g., location, video/audio, as well as biometric information); (ii) are built on top
https://doi.org/10/j.jss
0164-1212/© 2022 The Authors. Published by Elsevier Inc. This is an open access article under the CC BY-NC-ND license (http://creativecommons.org/licenses/by-nc-nd/4/).
# A. Mazuera-Rozo, C. Escobar-Velásquez, J. Espitia-Acero et al.
# The Journal of Systems & Software 187 (2022) 111233
of a specific framework and programming model, that, as we will show, requires to carefully handle specific types of resources and components (e.g., Activities, Intents, Broadcast Receivers, etc.); (iii) despite the Android OS is built on top of the Linux kernel, several modifications have been done to the kernel, and there is a set of specific OS layers built on top of the kernel that makes Android apps programming different from web and desktop app programming, even the programming model is different from the iOS model. In this paper, we focus on Android apps written in Java and in Kotlin, the two main programming languages officially supported for the development of Android apps.
Despite previous individual efforts for analyzing, detecting and fixing specific sets of security weaknesses, the research community still lacks a body of knowledge characterizing the types of weaknesses affecting Android apps. Also, some of the empirical investigations performed in the past could become outdated due to the frenetic evolution of the Android ecosystem. Indeed, the programming models include now the possibility of creating native, hybrid, cross-platform, and mobile web apps for the Android platform. Previous studies on specific security vulnerabilities have focused on analyzing Android Java apps, because of the availability of code bases and APKs in this language. Given the rising interest for Kotlin apps and its status of official Android language, investigating security weaknesses in Kotlin becomes a required avenue for research. While Dart/Flutter also represent interesting targets for research, their diffusion is still limited, with ∼18k GitHub repositories as compared to the ∼75k Kotlin repositories .
In this paper, we present the first empirical study characterizing software security weaknesses in Android Java and Kotlin apps. To this end, we build a taxonomy of security weaknesses by (i) manually analyzing 681 commits in open source Android Java/Kotlin apps (i.e., mining-based study), and (ii) surveying 43 Android developers to collect their experience with security weaknesses, and in particular with the types they frequently faced (i.e., survey-based study). The output of the mining-based study is a taxonomy on multiple levels featuring a total of 74 categories of security weaknesses.
As results of the developers’ survey, we identified 28 types of security weaknesses, of which 22 were already covered in our taxonomy, and six more were added. We use the defined taxonomy to discuss interesting directions for future research in the area, and lessons learned for practitioners.
Note that, while catalogues of security weaknesses in mobile apps have been previously defined (CWE, 2020; The OWASP Foundation, 2020), they are not based on the empirical observation of weaknesses affecting real mobile apps and, as a result, they are less comprehensive than the taxonomy we derive in this work.
# 2. Study design
The goal of the study is to investigate software security weaknesses affecting Java and Kotlin Android apps. The context consists of (i) 681 commits performed by software developers of Android apps to fix software security weaknesses, and (ii) answers to a survey conducted with 43 Android developers to investigate the software security weaknesses they face and how they deal with their identification and fixing.
Our study addresses the following research question:
RQ1: What are the types of software security weaknesses faced by the developers of Java and Kotlin Android apps?
To answer RQ1, we combine two orthogonal analyses. We start by manually analyzing a set of 681 commits fixing security weaknesses performed in 315 Java and Kotlin open source Android apps with the goal of defining a taxonomy of software security weaknesses faced by Android developers. We analyze both apps written in Java and in Kotlin, by presenting the differences (if any) in the distribution of security issues across the two languages. Then, we run a survey with 43 Android developers. The survey has a dual goal. First, we “validate” the taxonomy defined in the first step, by asking developers which security weaknesses they address more often. This allows to assess the comprehensiveness of our taxonomy and to complement it with new categories of security weaknesses if needed. Second, we collect additional data reporting how developers perceive security weaknesses in Android apps.
# 2. Manual analysis of commits
We present the procedure to collect the data needed for our study (i.e., commits fixing security weaknesses we manually validated) and the process performed to derive our taxonomy.
# 2. Data collection
As previously explained, Java has been historically the official programming language for creating Android apps. However, in 2019, Google announced that Kotlin is its official and preferred language for native Android apps. Thus, when selecting the mobile apps to study, we made sure to have a mix of Java and Kotlin apps by (i) merging different datasets available in the literature, and (ii) mining a dataset we created for this study. Keep in mind that for all considered apps we must have access to their repositories, since we later mine their commits. Having in mind previously mentioned considerations, we adopted the three following datasets.
Geiger et al. (2018) This dataset is composed of 8431 real-world open-source Android apps. It combines source and commit history information from GitHub with metadata from Google Play store. We processed the dataset to exclude apps that are no longer available on GitHub, leading to 7862 apps currently usable from this dataset (all available both on GitHub and on the Google Play store).
Coppola et al. (2019) The authors of this dataset mined all projects hosted on F-Droid, a repository for free and open source Android apps. This dataset is interesting because Coppola et al. reported the presence of 19% of apps featuring Kotlin code among the 1232 mined apps. We excluded apps that are no longer available on GitHub and, for consistency with the previous dataset, also those not published in the Google Play store. This resulted in 472 projects.
GitHub archive. Since in the two previous datasets there is a prevalence of Java apps (also due to the fact that they were built before the announcement by Google pushing Android apps towards Kotlin), we ran a query on GH Archive using Google BigQuery, with the goal of identifying repositories having Kotlin as the primary language. The query is available in our online appendix (Mazuera-Rozo et al., 2021). The aforementioned query was run on March 1st, 2020, obtaining a list of 3967 repositories as a result. We sorted these projects by number of stars.
References:
- https://developer.android.com/kotlin/first.
- Dart is a programming language developed by Google and designed to support the implementation of applications, including mobile apps. https://dart.dev/.
- Flutter is a software development kit created by Google that is built on top of Dart and can be used to develop cross-platform applications. https://flutter.dev/.
- https://tcrn.ch/363AyBv.
- https://f-droid.org.
- https://www.gharchive.org.
# A. Mazuera-Rozo, C. Escobar-Velásquez, J. Espitia-Acero et al.
# The Journal of Systems & Software 187 (2022) 111233
descending order) and selected the top 5% (i.e., 200 repositories) for manual analysis. In particular, we checked that the 200 repositories were real-world Android apps available on the Play Store. From this screening, we obtained a list of 22 Kotlin apps to consider in our dataset.
We aggregated these three datasets and removed duplicates, obtaining a final list of 8157 open-source Android apps. The list is available in our replication package (Mazuera-Rozo et al., 2021).
We cloned all 8157 repositories and ran on them a customized version of git-vuln-finder (cve-search, 2020), a Python application aimed at finding commits likely to fix a security weakness. The search is based on a set of regular expressions applied on the commit message (Zhou and Sharma, 2017). While most of the used regular expressions are applicable in the context of mobile apps, the work by Zhou and Sharma (2017) focuses on web applications. Thus, we modified their tool by complementing the list of regular expressions with others we defined by looking at the list of security weaknesses relevant to mobile apps and present in the Common Weakness Enumeration (CWE8) version 4, a community-developed list of common software and hardware security weaknesses. Also, we considered a commit as relevant for our study if it explicitly mentions the name or id of any weakness present in the CWE dictionary. The adopted regular expressions are publicly available (Mazuera-Rozo et al., 2021).
After running git-vuln-finder on the 8157 projects, we identified a set of candidate commits from which we removed duplicates due to: (i) commits mined from both the master branch and other branches merged in the master; (ii) forked repositories. Also, we decided to keep in our dataset only commits in which the developers are modifying a single Java or Kotlin file (as identified by their extension). The rationale behind this decision is two-fold. First, if a developer mentions in the commit note that she is fixing a security weakness and only one file is modified in the commit, we can be sure that the fix happened in that file. Second, since we aim at classifying the type of security weakness involved in each commit, understanding a fix spanning across many files can be quite challenging, and lead to misclassifications.
This cleaning process resulted in a final list of 4781 candidate commits.
# 2. Open coding
Given the 4781 commits collected in the previous step, we manually analyzed 681 of them with the goal of describing, using a label, the type of security weakness fixed in the commit. The number of inspected commits ensures a significance interval (margin of error) of ±5% with a confidence level of 99%. We did not use random sampling for the selection of the commits to manually inspect. Indeed, in the set of 4781 candidate commits, there are 4391 commits impacting a Java file, and 390 modifying a Kotlin file. Since we aim at comparing the types of security weaknesses affecting these two main languages used to develop native Android apps, we decided to target the analysis of the same number of Java- and Kotlin-related commits. We targeted the inclusion of 200 valid commits per language (i.e., excluding commits labeled as false positive since they are not related to security weaknesses’ fix).
The choice of 200 was tailored on the amount of commits available for Kotlin, since we expected to find a substantial number of false positives as result of the regular expressions used to select the commits. By applying the process described in the following, we analyzed 360 Java-related commits (200 valid + 160 false positives) and 321 Kotlin-related commits (200 valid + 121 false positives).
8 https://cwe.mitre.org
# Structure of the survey used in our study.
Five authors took part to the labeling process that was supported by a web application. Each author independently labeled the commits randomly assigned to her/him by the web application, defining a “label” describing the security weakness fixed in each commit. To define such a label the authors manually inspected the diff of the commit and the message accompanying it. As a guideline for the label definition, the authors used the CWE 4 list. The authors reused as much as possible the list of security weaknesses in CWE, defining new labels only when needed. Moreover, the web application also showed the list of labels created so far, allowing the author to select one of the already defined labels. Since the number of possible labels (i.e., types of security weaknesses) is extremely high, such a choice helps using consistent naming while not introducing a substantial bias. In case the commit was not related to a security weakness fix, a false positive label was assigned, discarding the commit from the study. Each commit was assigned to two authors and, in cases for which there was no agreement between the two authors, the commit was assigned to a third author. Conflicts arisen for 344 commits (∼50% of 681). While such a number may look high, note that we considered as a conflict also cases in which the authors used two slightly different labels to express the same concept (e.g., CWE-703: improper check or handling of exceptional conditions vs. CWE-754: improper check for unusual or exceptional conditions). A total of 1706 labels was required in order to reach our target of assessing and characterizing 200 valid commits per programming language: two labels per each of the 400 valid commits (800), two labels for each of the 281 false positives we discarded (562), and one more label for each of the 344 solved conflicts (344).
As outcome, we present a taxonomy of software security weaknesses identified in the manual analysis and we complement our discussion with qualitative examples.
# 2. Survey with developers
We designed a survey aimed at investigating the types of security weaknesses that are found by developers in their apps and their perception about specific aspects of security weaknesses. The survey was designed to last at most 15 min, to maximize the survey completion rate. The survey structure is reported in Table 1. Note that we rephrased some of the questions to shorten them. First, we collected background information about participants (Q1 − Q5). If a participant answered “zero” to the part of Q4 related to the overall programming experience of native Android.
# A. Mazuera-Rozo, C. Escobar-Velásquez, J. Espitia-Acero et al.
# The Journal of Systems & Software 187 (2022) 111233
apps, the survey ended, and the participant was excluded from the study. This happened in 2 cases.
Then, Q6 − Q7 aimed to collect information about the developers’ perception of security weaknesses. For these questions we provided a predefined list of possible factors to check, with the possibility of specifying additional factors. For Q6, the predefined list included: Skill level required to exploit it, Motivation to exploit it, Chances for a successfully exploit, Number of agents needed for the exploit, Ease of discovery, Technical difficulty of the exploit, How well-known is the weakness, and How likely is the exploit to be detected. Concerning Q7: Confidentiality, Integrity, Availability, Accountability, Brand reputation, Business profits, and Privacy violation.
Q8 and Q9 aimed to validate/complement the taxonomy defined as output of the manual study, with Q8 focusing on the most frequent and Q9 on the most dangerous security weaknesses experienced by developers. Both these questions required an open answer. Two authors read each answer and assigned the CWE-ID(s) needed to describe the security weaknesses mentioned in each answer. A third author merged these tags and solved conflicts arisen for 15 answers (18%).
Since a respondent might have answered the same for Q8 and Q9, duplicates among these answers were removed to avoid counting twice the same security weakness mentioned by the same developer.
Finally, Q10 asked developers how they detect security weaknesses and whether they are supported by any tool.
We used convenience sampling to invite developers from companies we know to participate in our survey. Also, the link to the survey was shared in social media. We collected answers for ten days, with a total of 43 participants that completed our survey from nine countries (i.e., Argentina, Canada, Colombia, Germany, Hungary, Italy, Macedonia, Poland and USA). On average, the participants had ∼6 years of overall programming experience and approximately 3 years of Android development experience (see Fig. 1). The average testing experience is close to two years. Regarding their job position, 21% of participants are B.Sc. students, 7% M.Sc. students, 4% Ph.D students and 67% professional Android developers having different job positions in the industry (e.g., Senior Android developer, Technical leader, Project Management Engineer, Director).
# 2. Testing the generalizability of our taxonomy
Once obtained the final taxonomy including both categories defined through the mining-based study as well as those complemented by the developers’ survey, we assessed its generalizability. We used all 64 Kotlin-related commits we did not manually analyze while building our taxonomy and a sample of 186 Java-related (again, among those we did not analyze). Then, we asked two Master students both having experience in Android development and not involved in the taxonomy definition and unaware of its structure, to perform the same manual analysis previously described. Each of them independently evaluated all instances. Conflicts arisen in 68% of cases were solved through an open discussion between the two students and the first two authors of this work. The final output is a taxonomy of security weaknesses affecting Android apps, that we can compare with the taxonomy we defined to assess its stability. While in principle more Kotlin-related commits would be needed, we labeled all those we found by mining several datasets of Android apps.
# 2. Data analysis
We start by presenting the taxonomy of types of software security weaknesses output of our mining-based study. Then, we discuss how the developers’ survey helped in validating/complementing the obtained taxonomy. Finally, we report about the results of the generalizability study. The data used in our study are publicly available (Mazuera-Rozo et al., 2021).
# 3. Results
The taxonomy is derived by a total of 400 commits (200 for Java and 200 for Kotlin) we manually validated. However, there are 14 commits that were grouped in the Unclear category since in these cases, while it was clear the intent of fixing a security flaw, we were unable to derive the type of fixed security weakness. Each category in Fig. 2 is accompanied by one, two, or three numbers. The two numbers with white background represent the number of instances of the corresponding security weakness type we found in Java (top number) and Kotlin (bottom). The one with gray background represents the number of developers that mentioned the type of security weakness in our survey. Categories added to our taxonomy as the result of the survey (e.g., CWE-625: Permissive Regular Expression), only have a gray-background number.
It is worth noting that some categories have only been found in a few commits or have only been mentioned by developers (but not found in the mining-based study). Concerning the first case (i.e., low number of commits related to the category), we preferred to still include those categories since, thanks to the numbers attached to them, it is easy for the reader to assess their relevance. In other words, it is clear from our taxonomy that, for example, the prevalence of CWE-691 vulnerabilities (78 overall instances) is much higher as compared to CWE-779 (3 overall instances). Concerning the latter case (i.e., categories only mentioned by developers), they increase the comprehensiveness of our taxonomy; the fact that we did not find them in the analyzed sample of commits does not make them less relevant for our study. Indeed, while we analyzed a substantial set of commits (400), it is reasonable to expect that we did not encounter specific types of vulnerabilities in our study (as we will also show in Section 3).
In addition, it is worth mentioning the hierarchical organization of the categories, moving from the most general categories (i.e., the root nodes, such as CWE-710), to more specialized ones (e.g., CWE-1164) down to the leafs (e.g., CWE-1069). The sum of instances for all child categories of a given node is lower or equal than the number of instances reported in its parent node. For example, CWE-1069 and CWE-561 are the two child categories.
A. Mazuera-Rozo, C. Escobar-Velásquez, J. Espitia-Acero et al.
The Journal of Systems & Software 187 (2022) 111233
5
# A. Mazuera-Rozo, C. Escobar-Velásquez, J. Espitia-Acero et al.
# The Journal of Systems & Software 187 (2022) 111233
of CWE-1164 (top-left corner of Fig. 2). CWE-1069 and CWE-561 have 1 and 11 Java-related instances, respectively, while their parent category CWE-1164 has 18 Java-related instances. This is due to the labeling process since we assigned to each commit the most specific security weakness type we could derive from the manual inspection. Thus, for 12 of the 18 commits belonging to CWE-1164 we managed to provide a more specific categorization, resulting in the two child categories, while for 6 of them CWE-1164 was the most detailed label we could assign. Finally, some categories are not linked to any CWE-ID. These categories are either (i) aggregating some sub-categories for better visualization, or (ii) created by the authors since they did not find a proper type within the CWE dictionary to classify an instance (See Table 2).
We start by discussing the categories output of the manual analysis (Section 3), presenting then the main differences between Java and Kotlin-related security weaknesses (Section 3), and then discussing how the developers survey validated/complemented our taxonomy (Section 3). Finally, we present the results of the further manual validation performed by two Master students to test the generalizability of our taxonomy. We use icons to highlight parts related to implications for researchers and practitioners.
# 3. Mining-based study
(1) Improper Control of a Resource Through its Lifetime (145 instances - 36%). It includes security weaknesses related to not maintaining or incorrectly maintaining control over a resource throughout its lifetime of creation, use, and release, leading to potentially exploitable states. A strongly represented type in this category is CWE-557: Concurrency Issues, being prominent in both Java (29 instances) and Kotlin (40).
Another common weakness related to the improper control of resources is CWE-668: Exposure of Resource to Wrong Sphere, with 11 instances found in Java and 8 in Kotlin. CWE-668 arises when a resource is inadvertently exposed due to insecure permissions or unexpected execution scenarios. Fig. 4 shows Kotlin code in which the developer sets the FLAG_SECURE to a window showing a password in the app.
The added flag asks the window manager to disable screen recording/capturing when the showPassword method is executed. The usage of this flag in windows containing sensitive information is recommended in the official Android documentation. Also in this case, techniques can be developed by researchers to automatically identify features in code that (i) deal with sensitive information that can be detected through simple keyword matching mechanisms (e.g., looking for words like “password”), and (ii) are in charge of displaying windows. Then, a simple automatic addition of proper flags can avoid potential points of attack. Such a security issue is also documented in Stack Overflow.
This suggests the potential usefulness for developers of recommender systems able to point out them to relevant Stack Overflow discussions while writing code (e.g., Prompter Ponzanelli et al., 2016). Making the developer aware of such issues at coding time can avoid the introduction of the security flaw in the first place.
Other types of security weaknesses that are less diffused but still relevant in the context of controlling resources are: CWE-178: Improper Handling of Case Sensitivity (12 cases) and CWE-665: Improper Initialization (13). The complete dataset of labeled weaknesses is available in the replication package (Mazuera-Rozo et al., 2021).
(2) Improper Adherence to Coding Standards (98 instances - 24%). This category frames security weaknesses present in software due to ignored development best practices. The most represented sub-category for both programming languages is CWE-1164: Irrelevant Code, with 18 Java and 19 Kotlin instances. This category is related, for example, to the presence of dead code in the apps (i.e., code that is not executed in any of the app’s features). Such code, while not executed in the normal app’s usage, can still be unintentionally invoked/tested by software developers, or even exploited and executed by an attacker. The execution of dead code can be particularly dangerous since it is often not maintained with the latest security-related updates.
A. Mazuera-Rozo, C. Escobar-Velásquez, J. Espitia-Acero et al. The Journal of Systems & Software 187 (2022) 111233
Notice that for both investigated languages, dead code is not removed from the APK (i.e., the compiled app) after compilation. Besides being possibly exploited, dead code can “come back to life” by mistake, thus leading to unexpected consequences. For example, the implementation of a new feature can by mistake be invoking an old (dead) implementation of a method accessing the database, leading to a loss of information when the app is deployed. In addition, dead code “might indirectly make it easier to introduce security-relevant weaknesses or make them more difficult to detect” When dead code is identified, two strategies are usually adopted by developers to remove it : (i) adding an explanatory comment before the dead fragment in question in which the developer mentions that the fragment it is or could be dead; and (ii) commenting out the code, leaving it available for future usage. The latter strategy is the one that has been applied in one of the fixing commits we inspected. The developer is commenting out dead code that seems to be related to the management of contacts in the database. Two days before this commit, the same developer added a comment on top of the dead code saying //TODO: what is this for again? (see changes to file MVP_Activity_Contacts in commit f0801d88).
The prevalence of CWE-561: Dead Code weaknesses in our fuzzers that work at source-code level for Kotlin nor Dart/Flutter taxonomy confirms the importance for researchers to investigate approaches able to automatically identify code components that can be removed without ripple effects on the code functionalities. To the best of our knowledge, very few tools are available for this task such as the one by Romano et al. (2020), the Android Lint tool , and the Kotlin DCE plugin .
Another well-represented subcategory is CWE-248: Uncaught Exception, that may cause the program to crash and/or expose sensitive information. Uncaught exceptions are a well-known issue in Android apps, especially when apps strongly rely on Android abstractions (e.g., activities, asynctasks, etc.) . The prevalence of this type of weakness in our taxonomy supports previous findings reported in the literature, and highlights the potential usefulness for developers of tools developed in academia to automatically test Android apps using systematic input generation (see e.g., Liñán et al., 2018; Li et al., 2017).
# (4) Protection Mechanism Failure (59 instances - 14%)
These security weaknesses are related to the incorrect restriction of access to a resource from an unauthorized actor. Thus, an attacker can compromise the security of the app by gaining privileges, accessing sensitive information, etc. Most of the weaknesses in this category are related to CWE-287: Improper Authentication. Fig. 5 shows an example of this type of security weakness, in which the developer fixes a security bug due to the missing authentication step in a feature requiring the user to have a valid authorization.
# (3) Improper Check or Handling of Exceptional Conditions (84 instances - 21%)
This category includes weaknesses that can lead to unpredictable behavior due to the improper or missing handling of exceptional conditions rarely occurring during the normal operation of the app. Within this category, the most represented type of security weakness is CWE-707: Improper Neutralization, happening when messages and/or data are not properly checked to be well-formed, valid, or benign (i.e., the exceptional condition of malformed messages/data is not properly handled). This category is mostly composed by cases related to CWE-20: Improper Input Validation (e.g., issues related to the improper validation of the password in a login form, such as commit 4875515b in the ccomeaux/boardgamegeek4android app, which could lead to a future credential management error).
This type of issues can be addressed by relying on dynamic analysis, and in particular on fuzz testing, which aims at feeding unexpected input data that may generate crashes, exploit security weaknesses, or induce unexpected states in the app. Several tools for this scope exist nowadays (Arzt et al., 2014; Google, 2019c; Ye et al., 2013; Huang et al., 2019; Cai and Jenkins, 2018; Fang et al., 2015; Nilizadeh et al., 2019), thus giving to practitioners a vast repertory of available options that can be adopted for their testing activities.
However, these tools work on Java and to the best of our knowledge, there are neither proposals of use of hard-coded credentials, such as commit f92221f from the UserLAnd app
12 https://cwe.mitre.org/data/definitions/561.html.
13 https://github.com/CypherpunkArmory/UserLAnd/commit/f92221f.
# A. Mazuera-Rozo, C. Escobar-Velásquez, J. Espitia-Acero et al.
# The Journal of Systems & Software 187 (2022) 111233
# 3. Java vs. Kotlin
This section compares the distribution of security weaknesses we observed in Java and Kotlin code. We focus on second-level categories (i.e., the direct child nodes of the root categories). We do not consider in this discussion categories in which there are less than ten overall instances when summing up the weaknesses for Java and Kotlin. Indeed, whatever observation made for these categories may be due to the low number of instances in the category. Also, it is worth noting that our goal is simply to highlight the differences we found in our taxonomy. Indeed, explaining the reasons for the observed differences without best-guessing is not possible with the available empirical data. A different experimental design targeting this RQ is needed to properly answer it.
We found a balanced distribution of Kotlin/Java instances among most of the subcategories. In particular, no major differences are observed in the subtree related to CWE-710: Improper Adherence to Coding Standards. Instead, when moving to the CWE-664: Improper Control of a Resource Through its Lifetime subtree, we observe a slight prevalence of Kotlin-related security weaknesses. This is mostly due to more issues related to improper thread synchronization and handling of case sensitivity (i.e., the code does not properly handle differences in case sensitivity, possibly leading to inconsistent results).
Concerning the CWE-703: Improper Check or Handling of Exceptional Conditions tree, the main category exhibiting differences.
# 3. Survey with Developers
Our taxonomy has been validated/complemented through the survey we performed with software developers. In the developers’ answers to Q8 and Q9 (see Table 1), we found mentions to 87 software security weaknesses, that can be classified into the 28 types labeled with a gray number (i.e., the number of developers who mentioned that security weakness type) in Fig. 2. Out of these, 22 were already part of our taxonomy as output of the mining-based study, while six were added: CWE-269: Improper Privilege Management, CWE-325: Missing Required Cryptographic Step, CWE-625: Permissive Regular Expression, CWE-1104: Use of Unmaintained Third Party Components, Hijacking, and Missing Code Obfuscation. The fact that 78% of the security weakness types mentioned by developers (22/28) were already part of our taxonomy, provides a good level of confidence about its comprehensiveness.
The most common security weaknesses (Q8) mentioned by the surveyed developers can be easily seen in Fig. 2, with those belonging to the CWE-693: Protection Mechanism Failure and CWE-664: Improper Control of a Resource Through its Lifetime trees representing 81% of the mentioned security weaknesses (71/87). There is a common thread we found when analyzing the answers provided to Q9, meaning the most dangerous weaknesses perceived by developers. All developers are mostly worried about unauthorized access to sensitive, private data stored in the app or sent/received through/by it. Some of the (shortened) answers: ‘vulnerabilities related to confidentiality, since they can expose user information’, ‘wrong/missing encryption of data being stored within the app’, ‘the leak of user personal information’.
Answers to Q9 confirm the importance of research studying security weaknesses related to data stored/manipulated by the apps (Arzt et al., 2014; Bello-Jiménez et al., 2019; Zhang et al., 2013).
An orthogonal view about the harmfulness of security weaknesses as perceived by developers is given by the answers to Q6 (i.e., the factors impacting the likelihood of a security weakness to be exploited) and Q7 (i.e., the factors impacting the harmfulness of the security weakness if exploited).
Developers pointed to technical aspects when answering Q6, indicating the difficulty of exploiting a security weakness as more important than the motivation to exploit it (i.e., the actual gain an attacker gets). Indeed, the difficulty of exploiting has been mentioned by 79% of the surveyed developers, as compared to the ∼56% mentioning the potential gain. Answers to Q7 stress again the importance for developers of protecting sensitive information, with most (88%) of the respondents reporting confidentiality and privacy violations as the main factors impacting the dangerousness of a security weakness.
Finally, we analyze the answers provided for Q10, related to the tools used by developers to detect security weaknesses. None of the surveyed developers mentioned tools developed in academia. Clearly, this does not mean that the adopted tools do not use any idea proposed in the literature.
Among the mentioned ones (available in our replication package) there are AppScan from IBM (2020), Infer from Facebook.
# A. Mazuera-Rozo, C. Escobar-Velásquez, J. Espitia-Acero et al.
# The Journal of Systems & Software 187 (2022) 111233
# Security weaknesses mentioned by developers: Available tools.
(2020), SonarQube (2020), and pre-launch reports given by Google Play when uploading the app to the market. Then, we looked into the relevant literature for tools that can be used by developers to detect the types of security weaknesses they more often face or they perceive as more dangerous (i.e., previously analyzed answers to Q8 and Q9). Table 3 reports categories of security weaknesses with corresponding references presenting approaches for their detection. Some categories are merged in a single row since their security weaknesses are quite similar, and approaches related for one category should work for the other as well. For 12 of the 28 types of security weaknesses mentioned by developers we found at least one approach supporting their automatic detection. On the one side, this shows that the research community is working on security weaknesses that are relevant for developers. On the other side, the developed approaches are unknown (at least) to our small pool of surveyed developers. This may also be due to the unavailability of industry-strength products implementing these approaches.
# 3. Stability of the taxonomy
Among the 250 commits analyzed by the two Master students (see Section 2 for details), 73 were classified as false positives for Java and 24 for Kotlin. This left us with 153 valid instances that have been used for the construction of the validation taxonomy (See Fig. 7). Looking at it, it can be seen that 85% of the identified categories are already covered in our taxonomy and only 8 new categories were identified (i.e., CWE-22: Improper Limitation of a Pathname to a Restricted Directory, CWE-372: Incomplete Internal State Distinction, CWE-392: Missing Report of Error Condition, CWE-400: Uncontrolled Resource Consumption, CWE-446: UI Discrepancy for Security Feature, CWE-474: Use of Function with Inconsistent Implementations, CWE-544: Missing Standardized Error Handling Mechanism, and CWE-766: Critical Data Element Declared Public). Also, all these categories are child of one of our root categories. This indicates a good generalizability of our taxonomy. Additionally, although the proportion of Kotlin artifacts is considerably lower than the amount of Java ones, it is worth noting that in the two taxonomies the distribution of types of security weaknesses across Java and Kotlin is similar.
# 4. Threats to validity
# Construct validity.
We identified through manual analysis the types of security weaknesses fixed by developers. To mitigate subjectivity bias, two authors have been assigned to each commit and, in case of conflict, the commit was assigned to a third evaluator.
Also, when the type of security flaw being fixed was not clear, we assigned the “unclear” tag rather than best-guessing the classification. Despite this mitigation strategies, imprecisions are still possible. Concerning the survey, we tried to not bias the participants’ answers especially in the context of questions asking for the most common/dangerous security weaknesses they faced in their apps. For this reason, we did not provide a multiple choice answer but we used an open answer.
# Internal validity.
In the survey, we collected information about the background of the participants, and excluded developers having no experience with native Android apps. For the manual study, we acknowledge that we only analyzed one specific source of information (i.e., security weakness-fixing commits) and this may have an impact on the derived taxonomy. Similarly, we only included in the manual analysis commits that impacted a single file, to make sure that the “security weakness” mentioned in the commit message was located in that file. Again, this could have affected the resulting taxonomy.
# External validity.
We manually analyzed a total of 681 security weakness-fixing commits coming from 315 apps. However, due to the removal of false positives and “unclear” instances, our taxonomy is based on 386 actual instances. Also, we asked two Master students to analyze an additional set of 250 instances to test the generalizability of our taxonomy. Analyzing additional instances and other orthogonal sources of information (e.g., ) could complement our taxonomy. As for the survey, we collected a total of 43 complete answers. While this number is limited, it is in line with many previously published survey studies in software engineering (see e.g., Dagenais et al., 2010; Canfora et al., 2012; Romano et al., 2020).
A. Mazuera-Rozo, C. Escobar-Velásquez, J. Espitia-Acero et al.
The Journal of Systems & Software 187 (2022) 111233
10
# A. Mazuera-Rozo, C. Escobar-Velásquez, J. Espitia-Acero et al.
# The Journal of Systems & Software 187 (2022) 111233
# Empirical studies on security weaknesses in Android apps.
# 5. Related work
Several techniques have been proposed to detect, and in some cases fix, vulnerabilities in mobile apps (e.g., Arzt et al., 2014; Li et al., 2015; Sadeghi et al., 2017; Lee et al., 2017; Singleton et al., 2019; You et al., 2016; Bello-Jiménez et al., 2019). We focus on studies investigating security-related aspects in Android apps, since these are the most related to our work. Table 4 provides an overview of the discussed studies, reporting for each reference, the year of publication, a brief summary of its contribution, the size of the dataset including the number of analyzed apps (#a) or commits (#c) since our paper reports this information, along with the number of security weaknesses types and categories that have been outlined.
Felt et al. (2011) identified over-privileges in the permissions (e.g., bluetooth, read contacts) of one-third of the 940 Android apps they analyzed. 10 most common unnecessary permissions are identified, and the percentage of overprivileged applications varies from 5% to 16%. The authors point out that this is mainly due to developers not interpreting correctly the API documentation. The results of our work, and especially of our survey, support the relevance of permissions for the vulnerabilities affecting Android apps.
Enck et al. (2011) investigated the root causes of vulnerabilities in 1100 free Android apps. The authors find misuse of sensitive information (i.e., phone identifiers and geographic location) among the root causes. Android-specific vulnerabilities relate all to the sensitivity of data, and 8 different types are identified, e.g., leaking information to logs, unprotected broadcast receivers, etc. The security of Android APIs was also considered insufficient, but no vulnerability was found able to maliciously control the apps.
The mishandling of sensitive information is also a prevalent aspect in our taxonomy.
Egele et al. (2013) used a static analysis technique to capture cryptographic misuses in 11k+ apps. They showed that 88% of the analyzed apps do not correctly use cryptographic APIs. This is mainly due to the lack of inter-procedural analysis that correlates multiple functionalities (e.g., encryption and decryption) within a method instantiation. Focus here is on cryptography, and 6 different types of violations (e.g., constant encryption keys) have been highlighted. Instances of issues related to cryptography are found both in Java and Kotlin in our taxonomy.
Sufatrio et al. (2015) presented a secondary study reviewing the literature about existing security solutions for Android apps. The taxonomy is relevant for five deployment stages, i.e., development, availability on markets, installation on a device, execution, and security settings modification. It surveys existing work, it does not rely on a specific dataset of analyzed apps/commits, but it elaborates on the literature to derive a taxonomy including 5 categories and 18 types of security vulnerabilities that should be prevented.
Zuo et al. (2015) exploited static and dynamic analysis to detect apps opening https web pages with illegal certificates.
It targets a specific category of vulnerabilities, i.e., the privacy of the communications. The developed framework detects a specific type of violation, i.e., ignoring the illegal certificate error and proceeding with the sending of sensitive information over an insecure communication channel. Bagheri et al. (2015) analyzed inter-app and inter-component security vulnerabilities in 500 apps. Specifically, a formal model expressing security properties of apps/components is extracted and a model checker verifies the safety of simultaneously running two apps that may interact while holding certain permissions. This research focuses on identifying a specific category of vulnerability, i.e., privilege escalation — an application with less permissions can be not restricted to access components of a more privileged application. Two types of detection strategies are adopted: (i) entities that can be inferred from a method; (ii) vulnerable paths of communication between entities. Also Ahmad et al. (2016) analyzed inter-app communication (IAC) in 52k apps, where the focus is on different types of actors involved in IAC (Library, Caller, and Callee), which are recognized as types of entities potentially vulnerable. Overall, these works  focus on a specific category of security vulnerabilities that, also due to the nature of our investigation (intentionally meant to be more general), we did not identify in our study.
Android devices and the operating system have been also investigated. Meng et al. (2018) presented a taxonomy of 63 device exploits (i.e., vulnerabilities leading to privilege escalation) grouped in 3 main categories that are related to perspectives: societal, practical, and technical. It is shown that the diffusion of exploits is decreasing due to Android systems and Linux kernels strengthening their security mechanisms. Our study does not limit its focus to exploits, but looks at security weaknesses from a more general perspective.
Jimenez et al. (2016) presented a taxonomy of 43 issues related to Android OS vulnerabilities by leveraging the CVE-NVD (Common Vulnerability Exposures - National Vulnerability Database) database whose size is left unspecified. The authors found that Android vulnerabilities related to the code mainly belong to 9 categories (e.g., resource management, handling data, etc.). They are mainly located in components dealing with browsing, cryptography, access control or networking. Also the fixing of vulnerabilities is investigated looking at the distribution of code changes, and most of them related to the additions of condition(s), authorization, functions, etc. Mazuera-Rozo et al. (2019) also performed empirical studies on the Android OS to categorize the types of the vulnerabilities (e.g., denial of service, improper authorization), their evolution overtime and their survivability. Security weaknesses are grouped in 14 categories where 154 types (e.g., credentials management, improper authorization, transmission of sensitive information, etc.) have been identified. Besides, vulnerability patches (e.g., check for exceptional conditions, proper handling of certificates, appropriate initialization values for variables) are analyzed to investigate the most used fixes. Our work, while related, focuses on security weaknesses affecting Android apps rather than the Android OS.
# A. Mazuera-Rozo, C. Escobar-Velásquez, J. Espitia-Acero et al.
# The Journal of Systems & Software 187 (2022) 111233
Weir et al. (2020) conducted a survey on the effect of requirements and developer practices on apps’ security. For app development, security is perceived relevant by the participants, even if assurance techniques are poorly used. The survey refers to a set of 454 apps, and 335 developers were using tools suitable to check the following 3 types of weaknesses: SSL security, cryptographic API misuse, and privacy leaks. As result, a portion of participants have been classified as security specialists and they advocated the usage of cryptography to enforce security.
Gao et al. (2021) investigated the temporal evolution of vulnerabilities in Android apps. Vulnerable code is detected in terms of which locations (e.g., library code) are more common than others, the types of code change (e.g., the addition of new files) that may entail security-related issues, and also if there is a correlation with malwares. The list of considered vulnerabilities is constituted of 4 categories (i.e., security features, permissions, injection flaws and data/communication handling) and 10 types, each associated to a detection tool providing evidence of the corresponding vulnerability.
To the best of our knowledge, our work represents the first and most comprehensive taxonomy of security weaknesses in Android apps, including both Java and Kotlin app-related code. Besides, our taxonomy is the result of a two-phase study, involving the inspection of software-related artifacts (i.e., security weakness-fixing commits) and a survey with software developers. The derived taxonomy is more comprehensive and extensive, covering 18 of the 20 issues analyzed in previous papers by Enck et al. (2011), Egele et al. (2013), Zuo et al. (2015), Bagheri et al. (2015), Jimenez et al. (2016), Weir et al. (2020), and Gao et al. (2021). Finally, we focus on both Java and Kotlin code recently suggested in Coppola et al. (2019), while only Java-related security weaknesses are analyzed in previously mentioned works.
# 6. Conclusions
We presented the first available taxonomy of security weaknesses in Android apps that covers both Java- and Kotlin-related code. Our taxonomy features 80 types of software security weaknesses, and it is the result of both a mining-based study in which we manually inspected 681 commits fixing security weaknesses (that contributed 74 types of security weaknesses), and a survey performed with 43 developers (contributing six additional types). Our results discussion resulted in the identification of several lessons learned for both practitioners (see the icon in Section 3) and researchers (icon).
Our future work will be mostly driven by the findings discussed in Section 3. In particular, we plan to focus on the definition of techniques able to detect (and possibly automatically fix) security weaknesses that are (i) not currently supported by existing detection tools, (ii) frequently spread in real Android apps, and (iii) relevant for software developers. Besides, we are interested to investigate the portability of methodologies and tools detecting Java-based weaknesses in Kotlin-based code, to understand which changes are needed to enable interoperability between the two languages. Our study provides the foundations for such a research agenda.
# CRediT authorship contribution statement
Alejandro Mazuera-Rozo: Methodology, Conceptualization, Software, Validation, Formal analysis, Investigation, Data curation, Writing – original draft, Writing – review & editing, Visualization, Project administration. Camilo Escobar-Velásquez: Methodology, Conceptualization, Investigation, Data curation, Writing – original draft, Writing – review & editing. Juan Espitia-Acero: Investigation, Data curation. David Vega-Guzmán: Investigation, Data curation. Catia Trubiani: Methodology, Conceptualization, Investigation, Data curation, Writing – original draft, Writing – review & editing. Mario Linares-Vásquez: Methodology, Conceptualization, Investigation, Data curation, Writing – original draft, Writing – review & editing, Supervision, Funding acquisition. Gabriele Bavota: Methodology, Conceptualization, Investigation, Data curation, Writing – original draft, Writing – review & editing, Supervision, Funding acquisition.
# Declaration of competing interest
The authors declare that they have no known competing financial interests or personal relationships that could have appeared to influence the work reported in this paper.
# Data availability
The data used in our study are publicly available at Mazuera-Rozo et al. (2021).
# A. Mazuera-Rozo, C. Escobar-Velásquez, J. Espitia-Acero et al.
# The Journal of Systems & Software 187 (2022) 111233
# A. Mazuera-Rozo, C. Escobar-Velásquez, J. Espitia-Acero et al.
# The Journal of Systems & Software 187 (2022) 111233
# Authors
Alejandro Mazuera-Rozo is a Ph.D. student in the Faculty of Informatics at the Università della Svizzera italiana (USI), Switzerland; and a Ph.D. student in the Faculty of Engineering at Universidad de los Andes, Colombia. He received his M.S. in Information Security from Universidad de los Andes in 2018, and his B.S. in Telematics Engineering from Universidad Icesi in 2015. His research interests include information security, software quality and mobile development.
Camilo Escobar-Velásquez is a Ph.D. student at Universidad de los Andes in Colombia. He received his M.S. in Software Engineering from Universidad de los Andes in 2019. He received his B.S. in Systems and Computing Engineering - Minor: Mathematics from Universidad de los Andes in 2017. He is part of The Software Design Lab, where he has been part of research projects on evolution, maintenance and analysis of closed-source android apps, automation of software engineering tasks and software testing. He received a Google Latin American Research Award in 2018–2021. He received a Swiss Government Excellence Scholarships for Foreign Scholars in 2020. He served as a student volunteer for ICSME’2018, ICSE’2019, ASE’2019, ICSE’2020, ICSME’2020, and ICST’2020. He served as organizing committee in LANGETI’2020, program committee in ESEC/FSE’2021 and shadow program committee in MSR’2021. More information is available here: https://caev03.github.io.
Juan Espitia-Acero is a M.S student in the Faculty of Systems Engineering and Computing at the Universidad de los Andes, Colombia. He also received his B.S in Systems Engineering and Computing from Universidad de los Andes in 2020. He is involved in the tutoring of some courses regarding the M. S. program of Software Engineering from Universidad de los Andes. His research interests include general software architecture, automated testing, software quality, cybersecurity, and mobile development.
David Vega-Guzmán received his B.S. in Systems and Computing Engineering from Universidad de los Andes. He has worked as Teaching Assistant for the Mobile Development Course, and he is interested in M-Health solutions, cloud computing and cybersecurity.
Catia Trubiani is Assistant Professor at the Gran Sasso Science Institute (GSSI), L’Aquila, Italy. Before joining the GSSI, she has been with various international research institutes like the Imperial College of London, UK, and the Karlsruhe Institute of Technology, Germany. Her main research interests include the dependability analysis and refactoring of large-scale software systems under uncertainties. Among various research projects she is involved, she is principal investigator of the GSSI unit for the MIUR-PRIN project SEDUCE (Young Line action) and for the MIUR-FISR project MVM-Adapt. She recently received the Exceptional Reviewer Award for ICSA, and the 10-year Most Influential Paper Award for ICPE, both in 2021. More information is available here: http://cs.gssi.it/catia.trubiani.
Mario Linares-Vásquez is an Assistant Professor at Universidad de los Andes in Colombia. He received his Ph.D. degree in Computer Science from the College of William and Mary in 2016. He received his B.S. in Systems Engineering from Universidad Nacional de Colombia in 2005, and his M.S. in Systems Engineering and Computing from Universidad Nacional de Colombia in 2009. His research interests include software evolution and maintenance, software architecture, mining software repositories, application of data mining and machine learning techniques to support software engineering tasks, and mobile development.
Gabriele Bavota is an Assistant Professor at the Universitá della Svizzera italiana (USI), Switzerland. He received the Ph.D. degree in computer science from the University of Salerno, Italy, in 2013. His research interests include software maintenance, empirical software engineering, and mining software repository. He is the author of over 100 papers appeared in international journals, conferences and workshops. He received four ACM SIGSOFT Distinguished Paper awards at ASE 2013, ESEC-FSE 2015, ICSE 2015, and ASE 2017, the best paper award at SCAM 2012, and three distinguished reviewer awards at WCRE 2012, SANER 2015, and MSR 2015. He served as a Program Co-Chair for ICPC’16, SCAM’16, and SANER’17. He also serves and has served as organizing and program committee member of international conferences in the field of software engineering, such as ICSE, FSE, ASE, ICSME, MSR, SANER, ICPC, SCAM, and others.