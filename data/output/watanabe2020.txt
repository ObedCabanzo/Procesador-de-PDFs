# IEICE TRANS. INF. & SYST., VOL.E103–D, NO FEBRUARY 2020
# PAPER
# Special Section on Security, Privacy, Anonymity and Trust in Cyberspace Computing and Communications
# Study on the Vulnerabilities of Free and Paid Mobile Apps Associated with Software Library∗
Takuya WATANABE†,††a), Nonmember, Mitsuaki AKIYAMA†, Member, Fumihiro KANEI†, Nonmember, Eitaro SHIOJI†, Member, Yuta TAKATA†††, Nonmember, Bo SUN††††, Member, Yuta ISHII, Toshiki SHIBAHARA†, Nonmembers, Takeshi YAGI†††††, and Tatsuya MORI††b), Members
# SUMMARY
This paper reports a large-scale study that aims to understand how mobile application (app) vulnerabilities are associated with software libraries. We analyze both free and paid apps. Studying paid apps was quite meaningful because it helped us understand how differences in app development/maintenance affect the vulnerabilities associated with libraries. We analyzed 30k free and paid apps collected from the official Android marketplace. Our extensive analyses revealed that approximately 70%/50% of vulnerabilities of free/paid apps stem from software libraries, particularly from third-party libraries. Somewhat paradoxically, we found that more expensive/popular paid apps tend to have more vulnerabilities. This comes from the fact that more expensive/popular paid apps tend to have more functionality, i.e., more code and libraries, which increases the probability of vulnerabilities. Based on our findings, we provide suggestions to stakeholders of mobile app distribution ecosystems.
key words: mobile app, software library, vulnerability
# 1. Introduction
Software libraries play a vital role in the development of modern mobile applications (app). They enable developers to improve development efficiency and app quality. In fact, Wang et al. reported that more than 60% of sub-packages in Android apps originate from third-party libraries . Although software libraries offer many advantages, in some cases, they could be the source of security problems, e.g., vulnerabilities or potentially harmful functionalities. Chen et al.  recently reported that 6% of apps published to Google Play were potentially harmful apps associated with harmful software libraries. These observations indicate that libraries can be the origins of the mobile app vulnerabilities.
We report a large-scale study to understand how mobile app vulnerabilities are associated with software libraries.
Manuscript received March 10, 2019.
Manuscript revised October 20, 2019.
†The authors are with NTT Secure Platform Laboratories, Musashino-shi, 180–8585 Japan.
††The authors are with Waseda University, Tokyo, 169–8555 Japan.
†††The author is with PwC Cyber Services LLC, Tokyo, 100–0004 Japan.
††††The author is with National Institute of Information and Communications Technology, Koganei-shi, 184–8795 Japan.
†††††The author is with NTT Security (Japan) KK, Tokyo, 101–0021, Japan.
∗Early version of this paper  was presented at International Conference on Mining Software Repositories (MSR 2017).
a) E-mail: takuya.watanabe.yf@hco.ntt.co.jp
b) E-mail: mori@nsl.cs.waseda.ac.jp
DOI: 10/transinfINP0011
To the best of our knowledge, this is the first study that uses large datasets to systematically quantify the vulnerabilities associated with libraries. To perform our analysis, we developed two frameworks, Droid-L and Droid-V, to detect/classify software libraries used in mobile apps and quantify how vulnerable mobile app libraries are, respectively. By linking the output of the two frameworks, we can specify the mobile app vulnerabilities associated with libraries. As the number of active mobile apps published in prominent mobile app marketplaces has exceeded four million , using a small sample of apps may result in intrinsic bias. However, analyzing all available mobile apps is not feasible. Thus, we applied proper sampling approaches to generate a dataset that is sufficient to extract statistically reliable results. We adopted two sampling approaches, i.e., top-K relative to the number of installs and random sampling. Top-K reflects the most influential apps and random sampling reflects the statistics of each population.
A unique and noteworthy approach of this study is that we analyze both free and paid apps. Very few studies have investigated the security of paid apps. We employ a relatively large number of paid apps to ensure statistically reliable results. Studying paid apps enables us to understand how differences in the development/maintenance of apps affect vulnerabilities associated with libraries. We examined software updates for these apps six months after they were originally collected. We collected 2M free apps to construct a database (DB) to detect/classify the libraries used in apps. In total, we used 2M free apps and 30K paid apps for our analyses.
Our primary findings are as follows.
- Roughly 70% of free apps and roughly 50% of paid apps with vulnerabilities were vulnerable due to libraries.
- More expensive/popular paid apps tend to have more vulnerabilities than other paid apps.
- Paid apps tend to have not been updated for longer periods than the free apps; thus, vulnerable libraries in paid apps have not been updated for longer periods than the free apps.
- Approximately one-half of the vulnerabilities detected by existing vulnerability checking tools are found in unreachable code.
Based on these findings, we derive suggestions for stakeholders in mobile app distribution ecosystems.
Copyright c 2020 The Institute of Electronics, Information and Communication Engineers©
# WATANABE et al.: STUDY ON THE VULNERABILITIES OF FREE AND PAID MOBILE APPS
(Sect. 6).
The remainder of this paper is organized as follows. In Sect. 2, we present a high-level overview of the methodologies developed for our analysis. In Sects. 3 and 4, we describe the Droid-L and Droid-V frameworks, respectively. In Sect. 5, we characterize the dataset used for the analysis. Findings are presented in Sect. 6. Limitations of the analysis and future research directions are discussed in Sect. 7. We also consider ethical issues associated with this research in Sect. 7. Section 8 provides a summary of related work, and conclusions are presented in Sect. 9.
# 2. Overview of Methodologies
# 3. Droid-L: Library Detector
The Droid-L system detects and classifies software libraries. Figure 2 shows an overview of the Droid-L system, which comprises a fingerprint DB and a dead code checker. For a given APK file, the system first decompiles the file and extracts packages. The system then computes a fingerprint for each package and compares the computed fingerprints to the library fingerprint DB, which we describe in the next section. The fingerprint DB returns one of three library categories, i.e., official, private, or third-party. If the DB does not return anything, this implies that the package is not a library. Next, the system applies the dead code checker to the extracted libraries. The dead code checker employs static call graph analysis to determine if the detected library code is dead code. In the following, we describe these two components in detail.
# 3 Building the Fingerprint DB
As shown in Fig. 2, the role of the fingerprint DB is to classify a given package as official, private, or third-party (Sect. 3). To build such a DB, we take the following two-stage approach. First, we employ cluster analysis to extract a set of packages with similar characteristics, which we call a fingerprint. A fingerprint is a unique signature that represents an extracted cluster. Then, we classify the extracted clusters using two heuristics. The first heuristic is the naming convention of Java packages. Each package has an intrinsic name that may suggest which category it should belong to. For example, com.google.ads represents the AdSense library supported by the official Android SDK manager. The second heuristic is the number of distinct developer certificates per cluster. This feature is useful to determine how a detected library is used by developers. If it is a widely used public library, we will find many distinct certificates for apps that use the given library; if it is used by a single developer, the library is likely a private library. Once we build a library fingerprint using a large collection of apps, we can extract software libraries and classify them into categories for a given app. Note that we assume that code other than the detected software libraries is attributed to app developers. We discuss the limitation of this assumption in Sect. 3.
# 3 Clustering Packages
To detect libraries contained in the collected apps, we begin by clustering packages. Similar packages used in many apps are clustered. A set of clustered packages possibly represents a software library. There are several ways to cluster packages , , . LibRadar  leverages stable API.
# IEICE TRANS. INF. & SYST., VOL.E103–D, NO FEBRUARY 2020
features that are resilient to code obfuscation or minor software updates. LibFinder  compares two packages at the method level using control flow graphs.
Due to its simplicity and high scalability, we adopted the approach used in LibRadar as our base and extended it for our purpose. Note that we could adopt other clustering approaches, such as LibFinder or other clustering algorithms using features extracted from packages.
Following the LibRadar approach, we first extract packages for the given apps. Here let p be an extracted package. Next, for each p, we derive n(p), which is the total number of API calls in p, and m(p), which is the number of distinct API calls used in p. Finally, for a given package p, we compute its fingerprint F(p): F(p) = h(n(p), m(p)), where h() is a lightweight hash function. After processing all packages found in all apps, packages with the same fingerprint are clustered. We eliminate a cluster if it has only one package.
From the set of all package names found in a cluster, we choose the most frequently used name as the representative package name (RPN). The RPN offers a human-interpretable representation of a cluster while removing the noise introduced by developers who modify the names of packages. While extracting RPNs is common with LibRadar, the method we use to extract RPNs may not be identical because not all details are disclosed in Ref.  and in its open-source tool .
We also apply deobfuscation to package names by heuristically identifying and removing obfuscated package names (e.g., zzz.a.b.c) before choosing the RPN. For deobfuscation, we first extract words that are separated with dots from a given package name. If at least one of the words extracted is a single letter, we identify the package name as obfuscated. For example, if the package name zzz.a.b.c is given, we extract “zzz,” “a,” “b,” and “c” as words. Since the package name included three single-letter components, we detect it as obfuscated and eliminate it from the list of RPNs. Note that this simple rule may falsely eliminate legitimate package names that include a single letter. However, we found that such cases were not common in our datasets.
The extracted RPNs are useful for understanding the provenance of libraries. We use the RPNs to classify detected libraries into categories.
# 3 Library Classification
We aim to classify detected software libraries. Note that existing library detection schemes , ,  have not considered such classification. We define three library categories, i.e., official, private, and third-party, based on how they are distributed. This distinction is particularly important in relation to suggestions for managing libraries in the presence of vulnerabilities. We use RPNs and the number of distinct certificates per library for the classification task.
The descriptions of the three categories of libraries and the ways to detect them are summarized below:
Android SDK Manager , e.g., the Android Support Library. Detected if its RPN matches one of the package names provided by the SDK Manager, e.g., android.support. Private Libraries are those developed by a particular developer intended only to be used privately in apps developed by that developer, e.g., special logging/debugging libraries. Detected if all apps using the library are signed with a single signature. Third-Party Libraries are those distributed freely or commercially to be used by any developers, e.g., an advertisement library. Detected if it is not classified as an official library or a private library. We also listed examples of RPNs for each categories in Table 1.
Next, we classify third-party libraries into sub-categories that describe their functionality or purpose. We considered 8 sub-categories: Ad (Advertisement), Analyt (Mobile analytics), Build (App building framework), Cloud (Cloud-based app building), Dev (Development aid), Game (Game engines), Pymt (Payment), and SNS (Social networks). We also listed examples of RPNs for each sub-categories in Table 2. Our task is to assign a detected library/RPN to one of the categories.
First, we compile a list of package names that are associated with popular third-party libraries listed in websites such as . Let the compiled list be “list A.” Second, for RPNs that are not detected in list A, we manually inspect the top package names used for at least 100 distinct apps. We summarize the results as “list B.” Finally, for libraries not covered by lists A and B, we apply the following prefix-matching heuristics. For a given unclassified RPN C, if there is a classified RPN D that matches a prefix of C, then C is assigned the same category as D.
Finally, using the procedures described above, we construct a fingerprint DB. Each record consists of the following three-tuple, i.e., fingerprint, deobfuscated RPN, and class/category. The fingerprint DB is employed as follows.
# WATANABE et al.: STUDY ON THE VULNERABILITIES OF FREE AND PAID MOBILE APPS
We extract packages from a given APK file and compute a fingerprint for each package. By querying the obtained fingerprints in the DB, we can obtain corresponding deobfuscated RPNs and categories. Note that an APK file may contain code from multiple libraries in the same category, e.g., it is quite common that an app uses more than two distinct ad libraries.
# 3 Dead Code Checker
Since some detected vulnerabilities may reside in dead code, we must distinguish such cases from legitimate cases. Thus, we built a dead code checker that can determine whether a given class is reachable in a generated function call tree.
getf (Line 5) is a function that returns a list of methods that instantiate/call a class. refFunctions (line 21) is a function that returns a list of functions that reference the given function. As an implementation of refFunctions, we adopted Androguard , which we modified for our purpose. If a function of a class, say Foo, implements a function of the Android SDK class whose code is not included in the APK, we cannot trace the path from the function in some cases. To deal with such cases, we made a heuristic to trace the function that calls the init-method of class Foo (lines 16–19). We note that the heuristics can handle several cases such as async tasks, OS message handlers, or callbacks from framework APIs such as onClick(). A method is callable if it is overridden in a subclass or an implementation of the Android SDK and an instance of the class is created. Async tasks, the OS message handler, or other callbacks implement their function by overriding the methods of the Android SDK subclass. Therefore, this should be handled by heuristics. Finally, if there are no paths for which a given class can reach ORIGIN, the algorithm concludes that the class is a dead code.
Note that our approach has an intrinsic limitation associated with static code analysis. This will be discussed in the next subsection.
# 3 Threats to Validity
# 3 Accuracy of Results
To validate the accuracy of the results generated by the Droid-L system, we inspected the detected libraries manually. We randomly sampled 25 apps from each of four datasets, i.e., free top, free random, paid top, and paid random apps. We summarize the dataset in Sect. 5. These 100 apps contained 11,633 packages, which were grouped into 7,620 distinct clusters, and 85% of the clusters (6,460) were detected as libraries using the fingerprint DB. The remaining packages (1,160) were not detected as libraries for the following reasons. First, the fingerprints of those libraries have been changed due to software updates. Second, some libraries use code optimization tools, such as ProGuard, which could also change fingerprints. We then inspected the 6,460 packages manually. First, we disassembled/decompiled the APK files. Then, we looked at the detected packages and inspected the classes/methods within the packages. We also searched the origins of the package source code using Internet search engines. We found that 6,308 packages (97%) were classified correctly. This result clearly validates the accuracy of the Droid-L system.
# 3 Dead Code Checker
Static analysis, which is the basis of our approach, has the
# IEICE TRANS. INF. & SYST., VOL.E103–D, NO FEBRUARY 2020
280
following two limitations. First, although the algorithm can exclude dead code, we cannot precisely ensure that remaining code is actually used in the app. Second, static code analysis cannot dynamically track assigned program code at run time, such as reflection. These limitations are common among static analysis approaches.
# 4. Droid-V: Vulnerability Checker
Our next goal is to identify vulnerabilities in detected libraries. To this end, we built a vulnerability checker, i.e., Droid-V, which uses various vulnerability scanners and compiles their results for further analysis. Taking an app as input, Droid-V detects the presence of vulnerabilities and identifies where in the code the vulnerabilities reside. This information can be combined with the results of Droid-L to identify the responsible libraries. In this section, we list and describe the vulnerabilities we targeted. Some of the limitations of our system are also discussed.
# 4 Vulnerabilities
As summarized in Sect. 8, common and influential vulnerabilities found in recent mobile platforms can be broadly classified into four categories, i.e., information disclosure, SSL/TLS and cryptography, inter-component communication (ICC), and WebView. While the first two are underlying for all softwares, not just mobile apps and devices, the last two are mobile app/device-specific issues.
Each of these vulnerability categories has the following implications. Information disclosure involves the inclusion or improper access control of sensitive information that may lead to undesired leakage. Cryptography involves the misuse of SSL/TLS and cryptographic-related code, which may lead to cryptographic integrity being compromised. ICC involves improper permissions that may allow another app to access an app’s sensitive information. WebView involves the misuse of Android’s WebView class, which has been a source of many vulnerabilities, including remote code execution.
AB = AndroBugs, STF = Secret Token Finder, MD = MalloDroid, WCC = Weak Certificate Checker, and QA = QARK
AWS and Google OAuth tokens. MalloDroid ,  is an open-source tool for statically analyzing an APK file for various potential SSL related security flaws, such as the inclusion of an invalid SSL certificate or misuse in the SSL validation logic. We considered the app vulnerable if at least one of the flaws was detected. Weak Certificate Checker is a tool we implemented to find cryptographically weak certificates used to sign an APK file. It does several checks, such as whether a certificate was created with a key with less than 1,024 bits, or is vulnerable to certain attacks, e.g., Wiener’s attack and common modulus attack. We considered the app vulnerable if at least one of the flaws was detected. QARK  is an open-source tool for analyzing vulnerabilities of Android apps either in source code or packaged APKs. The tool automates the use of multiple decompilers and combines their outputs to improve results. It covers various security related Android application vulnerabilities such as the creation of world-readable or world-writable files, activities that may leak data, private keys embedded in the source code, apps that are debuggable, etc.
# 4 Threats to Validity
Similar to the Droid-L system, Droid-V employs static code analysis to perform a large-scale study. Clearly, static code analysis may not be able to track dynamically assigned program code. Poeplau et al.  reported that malicious apps using dynamic code loading techniques can evade detection using offline vetting processes, e.g., static analysis, anti-virus scanning, or dynamic analysis in a sandbox without Internet connectivity. A malicious app can contain only the minimal functionality sufficient to circumvent
# WATANABE et al.: STUDY ON THE VULNERABILITIES OF FREE AND PAID MOBILE APPS
the vetting process on Google Play, i.e., Bouncer . The malicious code is downloaded only after the app is installed on a device. Dynamic code loading is an obstacle to vulnerability assessment for external code for non-malicious apps. Employing dynamic code analysis with Internet connectivity could be a promising solution to this problem. However, dynamic code analysis has several technical challenges, i.e., scalability, measuring and improving code coverage, and generating a test scenario for UI navigation . We intend to address these challenges in future work.
# 5 Characteristics of Free/paid Apps
In the following analyses, we attempt to characterize the collected data. The derived characteristics are useful to understand the sources and impacts of vulnerabilities associated with libraries. In other words, we investigate the number of installs, prices, and number of classes.
# 5 Number of Installs
This section describes the free and paid app datasets used in our analysis. Since there have been no studies that analyzed paid mobile apps on a large scale, it would be meaningful to present how they are different from free apps. As discussed later, paid apps exhibit different characteristics compared to free apps. We construe that this reflects differences in app development and maintenance processes. We first provide an overview of datasets and then present interesting findings derived through an analysis of paid/free apps and the corresponding metadata, such as the prices of paid apps and the number of installs.
# 5 Data Description
We collected paid and free Android apps available on Google Play . We collected and used Android apps for two purposes. The first purpose was to generate the fingerprint DB (Sect. 3). To this end, we collected 2M free apps and 30K paid apps from Google Play. Table 4 summarizes the data collected to generate the fingerprint DB. The second purpose was to analyze the vulnerabilities of the libraries. Collecting and analyzing all paid and free apps on Google Play was not feasible due to budgetary and labor costs; thus, we made use of filtration and sampling as follows. First, we compiled lists of paid and free apps published on Google Play. From each list, we selected both the top-K and randomly sampled apps. The selected apps were divided into four sets, i.e., paid top, paid random, free top, and free random apps. The top-K apps represent the most influential apps, and the randomly sampled apps reflect the statistics of each population. We used the top-5k and random-10k (rand-10k) apps for our analysis. In total, we 30k apps were used in our analyses. To further investigate the changes of vulnerabilities of apps/libraries over time, we updated these apps six months after we first collected them. Results for updated apps are presented in Sect. 6.
# 5 Prices
In this study, we are interested in how prices correlates to vulnerabilities. It is known that customers use price-perceived quality heuristics  when appraising the quality of a product or service. It is natural to assume that such perception might reflect expectations regarding security risks. In other words, customers may believe that a paid app has fewer security risks than a free app. After analyzing the vulnerabilities of paid mobile apps in the next section, we return to this issue in Sect. 7.
# IEICE TRANS. INF. & SYST., VOL.E103–D, NO FEBRUARY 2020
282
# 5 Time of Last Update
We look into the time of the last update, which represents whether a particular app is actively developed/maintained. This information is useful for predicting the security awareness of a developer. For instance, if an app has not been updated for a long time, it may have more security risks than apps with recent updates. Ideally, it is good to use the full history of updates to measure the average time between updates. However, such information is not accessible from the web interface of the official market. As a substitute, we made use of the last date an app received an update. Though the last update date is more coarse-grained than the full history of updates, it gives us useful information about an app’s development activity.
# 5 Number of Classes
# 6. Analysis Results
This section describes the results we obtained through extensive analysis of the datasets. We first present the software libraries detected using the Droid-L system (Sect. 6). Then, we present vulnerable libraries found with the two systems, i.e., Droid-L and Droid-V (Sect. 6). We also analyze how these results have changed over time (Sect. 6). Finally, we summarize the key findings derived through the analyses. Based on the findings, we provide several suggestions to stakeholders (Sect. 6).
# 6 Detected Software Libraries
Tables 7 and 8 present breakdowns of the extracted libraries per category/sub-category. In Table 7, we see that, across all the datasets, third-party libraries accounted for roughly 70%–80% of the detected libraries. Official libraries accounted for roughly 20%–30% of the detected libraries. The number of detected private libraries was much smaller than other categories. Next, in Table 8, we see that, across all datasets, development aid (Dev) was the most dominant type of third-party library. This observation was
# WATANABE et al.: STUDY ON THE VULNERABILITIES OF FREE AND PAID MOBILE APPS
# 6 Analysis of Vulnerable Apps/Libraries
Here, we first present the statistics for apps that contain the summarized vulnerabilities. We then examine the libraries with vulnerabilities. We also examine how the detected vulnerable libraries changed over a period of six months. Note that an app could have a vulnerability contained in multiple libraries.
# 6 Vulnerable Apps
# IEICE TRANS. INF. & SYST., VOL.E103–D, NO FEBRUARY 2020
# Vulnerable Libraries
Here, we examine how many detected vulnerabilities were attributed to libraries. We also assess the origins of the vulnerable libraries. Table 10, Vlib shows the fractions of apps whose vulnerabilities originated from their libraries for all vulnerable apps. For free apps, of the apps that contain at least one vulnerability, 71%–72% were vulnerable due to libraries. For paid apps, the fractions were a bit smaller; however, 46%–52% were vulnerable due to libraries. Thus, we conclude that most mobile apps’ vulnerabilities originate from libraries. On the other hand, the p-value of the two-sample t-test for the top free apps and randomly sampled free apps exceeded 0. Thus, we did not see the difference of tendencies due to the popularity of the apps.
Finally, the bottom panel of Fig. 9 shows the relationship between third-party library sub-categories and vulnerabilities. Among the sub-categories, Development Aid (Dev), Social Network (SNS), Advertisement (Ad), and App building framework (Build) were the main origins of the vulnerabilities. In addition, each sub-category contains intrinsic vulnerability patterns, e.g., while Ad libraries mainly contributed to the ID-GLOB and WV-RCEV, SNS libraries mainly contributed to WV-SSLV and WV-DOMS.
# WATANABE et al.: STUDY ON THE VULNERABILITIES OF FREE AND PAID MOBILE APPS
285
# 6 Price vs. Vulnerabilities
# 6 Time-Domain Analysis
We examined how vulnerabilities in apps are addressed over time. Here, we examine the status of the same apps with vulnerabilities six months after we first acquired them, and
Note that these 4,525 vulnerabilities were found in the distinct 4,525 Java classes contained in the app. For each page of the book, the app declares a unique class rather than introducing a single generic class that represents a page. In other words, every time a user turns a page of the book, the app calls a new class. To fix this vulnerability, the developer must modify all 4,525 Java classes. Despite this rather poor code implementation, it is ranked as a top paid app and had been installed more than 10,000 times at the time of data collection.
In summary, even if an app is a paid app, it is likely to have vulnerabilities. Somewhat paradoxically, more expensive/popular paid apps tend to have more vulnerabilities. These results indicate that we cannot apply price-perceived quality heuristics when we appraise the quality of an app with respect to security.
# Figures
# IEICE TRANS. INF. & SYST., VOL.E103–D, NO FEBRUARY 2020
# 6 Key Findings and Suggestions
We summarize the statistics of the apps (Fig. 12). The percentage of apps removed from the marketplace in that period was less than 9% for each category. The percentages of apps that were updated are as follows: free (top): 59%, paid (top): 26%, free (random): 16%, and paid (random): 8%. The update intervals of paid and random apps were longer than that of free and top apps. We randomly acquired over one-half of the updated apps in the four categories and confirmed which vulnerabilities were fixed using Droid-V. The percentages of apps with fixed vulnerabilities indicate the same update interval tendency, i.e., paid and random apps were more difficult to fix than free and top apps. It is shown statistically since the p-values of the two-sample t-test between each category are less than 0. The percentages of apps whose vulnerabilities were fixed completely are as follows: free (top): 18%, paid (top): 6%, free (random): 4%, and paid (random): 2%. Unfortunately, a large proportion of apps were still vulnerable even six months after our initial investigation.
Free apps are updated in a short period due to their monetization model, i.e., updating an ad library to optimize advertising effectiveness. Therefore, vulnerabilities in libraries are fixed when apps are updated. Ruiz et al. indicated that ad libraries are frequently updated by advertising companies, and such frequent app updates force developers to update their apps. In contrast to the above freemium monetization model, premium monetization of paid apps results in less frequent updates. In addition, we assume that the effort spent on product development for random apps is less than that of top apps, and this results in infrequent updates for random apps.
The top three fixed vulnerabilities are CR-KSHC, ID-STOK, and WV-SSLV, and there is little difference between free and paid apps. The first two arise from the problem of hardcoded secret keys/tokens. WV-SSLV arises from problems with SSL validation. The reasons why these vulnerabilities are more likely fixed are as follows. First, CR-KSHC and ID-STOK are fairly easy to discover and fix. For instance, a developer can simply obfuscate secret keys/tokens. Second, since all these vulnerabilities pose a high risk to the integrity of server-side services, developers have motivation to fix them.
Here, we summarize key findings derived from our extensive analyses.
- Roughly 70% of free apps with vulnerabilities were vulnerable due to libraries, and Roughly 50% of paid apps with vulnerabilities were also vulnerable due to libraries.
- Among the three library categories, third-party libraries were the main source of vulnerabilities.
- While most vulnerable libraries originated from third-party libraries, a few official libraries were also detected as vulnerable due to the use of old versions.
- Paid apps can contain vulnerabilities, and more expensive/popular paid apps tend to have more vulnerabilities.
- Paid apps tend to have not been updated for longer periods than the free apps; thus, vulnerable libraries in paid apps have not been updated for longer periods than the free apps.
- Approximately one-half of the detected vulnerabilities were attributed to dead code. We demonstrated that Droid-L can successfully exclude such cases from analysis.
These key findings enable us to derive clues to remediate vulnerabilities in mobile app. We make the following suggestions to the stakeholders of mobile app distribution ecosystems, i.e., mobile app developers, mobile OS developers, app market operators, and mobile app library providers. We also offer a suggestion for the developers of vulnerability test tools.
- Mobile app developers: Developers of apps with many classes/libraries must pay more attention to their apps. They could apply vulnerability assessment before release to at least eliminate easily-detectable vulnerabilities. After the release of apps, they could also check the updates of libraries they use. As we discuss in short, building a systematic update checking mechanism will be useful.
- Mobile OS developers: Generally, infrequent updates lead to vulnerabilities. For instance, some paid apps adopt the “sell-once-and-that’s-it” model. For such apps, it may not be reasonable to expect developers to perform vulnerability assessment of their products. If a mobile OS provides an automated mechanism that updates obsolete libraries/codes in an app, that could address the vulnerabilities caused by outdated software.
- Mobile app market operators: Mobile app market operators should inspect all active apps using systems like Droid-L and Droid-V. In addition, they should provide vulnerability notification mechanisms that inform app developers of the sources of detected vulnerabilities. It may also be effective to present ways to update apps appropriately. Using systems like Droid-L and Droid-V, a mobile app market operator can also inform users of the potential risks of an app.
- Mobile app library providers: By linking Droid-L and Droid-V outputs, a list of libraries that contain vulnerabilities are generated. The results of our analysis would be useful for library providers to quickly know about the vulnerabilities and fix them.
- Vulnerability test developers: As reported, roughly
# WATANABE et al.: STUDY ON THE VULNERABILITIES OF FREE AND PAID MOBILE APPS
one-half of vulnerabilities detected by existing vulnerability check tools reside in dead code. The developers of such tools could implement a dead code checker to address this issue.
# 7. Discussion
This section discusses the limitations of our analyses, user perception of security risks, and ethical issues.
# 7 Limitations of the Analyses
As discussed in Sects. 3 and 4, both library detection and vulnerability checking are based on static analysis approaches. We are aware of the limitations and have described future work in previous sections. Another limitation we did not discuss is apps with native code. While our analysis focuses only on Java-written components, some Android apps contain both Java-written and native code components written in C/C++. The use of native code components is especially popular in game apps, which are required to run as quickly as possible. Afonso et al. mentioned that “Malicious apps can use native code to hide malicious actions. . . ” and surveyed how actual Android apps use native code . They revealed that most native code components are used to improve CPU-intensive workloads, such as graphics and audio, while several hundred apps out of 1M contain root exploits written in native code. However, their work was not a vulnerability survey; thus, investigating vulnerabilities in native code remains a challenge.
# 7 Ethics
We finally discuss three ethical issues.
- Acquisition of paid apps: All paid apps used for our analyses originated from the official Android marketplace, i.e., Google Play. We acquired all apps from the official marketplace according to the legitimate payment procedure. This means that we used our owned Google accounts to collect and purchase apps one by one without violating the Acceptable Use Policy.
- No additional harm: We conducted our app analysis in a test environment without Internet accessibility. Therefore, there was no damage to the actual apps, devices, and services.
- Responsible disclosure: After finding new vulnerabilities in apps and libraries, we followed the principle of responsible disclosure and reported them to CSIRTs. The disclosure includes the app and library names, the categories of vulnerability, and the source code, as well as suggested guidelines to reduce insecure code.
code provenance, which means identifying different components of an application, e.g., host apps and libraries and their developers , . These studies tackled the negative effects of a library and host app running without isolation with the same privileges. Li et al. indicated that piggybacked apps with a library containing malicious code can mislead security analysis . Bhoraskar et al. also mentioned that a host app as a whole can become vulnerable if there are bugs in the library .
Libraries play a vital role in improving the efficiency of developing applications and monetization (especially with ad libraries). As of 2012, 95% of popular free Android apps contained at least one known ad library . Unfortunately, several studies have revealed the risk of an ad library automatically harvesting privacy-sensitive data without sufficient explanation to users , . Andow et al. analyzed popular ad libraries and identified 15 libraries as madware, which exhibits aggressive advertising behaviors . Chen et al. addressed the problem of a potentially harmful library (PhaLib), which is potentially harmful code implemented as a library, and their developed tool for finding specific code over different mobile platforms (Android and iOS) discovered 117 Android PhaLibs and 46 iOS libraries . To estimate the risk of information leakage, Demetriou et al. developed a tool to discover apps that expose a targeted user’s privacy data to an integrated ad library .
Although many studies of software libraries aimed to discover malicious code, the motivation of our work is discovering vulnerabilities in libraries. To the best of our knowledge, our library analysis is the first work to classify libraries into three intrinsic categories, i.e., official, private, and third-party. This fine-grained library analysis helps app/library developers clarify the boundaries of responsibility for countering vulnerabilities and appropriate triage countermeasures. Backes et al. developed a library detection method called LibScout . LibScout is resilient against common code obfuscations and capable of pinpointing exact library versions. As we demonstrated in Sect. 3, the accuracy of Droid-L is high, however, we can also use these techniques as a complementary to the outputs of Droid-L.
Finally, some recent researches focus on the maintenance and updatability of mobile libraries. Yasumatsu et al.  revealed that 50% of library updates were performed for more than 3 months after its release, and 50% of outdated libraries used in mobile apps were left for more than 10 months. However, according to Derr et al. , 85% of the outdated libraries can be upgraded without modifying the app code. These findings are useful for developers to fix vulnerabilities in free and paid apps across various categories we identified and improving mobile apps market security.
# 8. Related Work
# 8 Library Analysis
A significant amount of recent research has shed light on
# 8 Vulnerability Analysis
There have been numerous studies related to vulnerability and malware/adware detection. Many of these studies applied their methods to actual apps for evaluation. Based
# IEICE TRANS. INF. & SYST., VOL.E103–D, NO FEBRUARY 2020
on studies that consider vulnerabilities and threats to mobile apps and devices, we classify such vulnerabilities into four categories, i.e., information disclosure, SSL/TLS and cryptography, inter-component communication, and WebView. The first two are broad underlying issues that are not solely related to mobile apps and devices. The last two are mobile app/device-specific issues.
# Information disclosure
Apps should be able to carefully process sensitive information, such as credentials; otherwise, there is a risk of information disclosure when broadcasting, logging, storing sensitive information, and setting improper file permissions. Viennot et al. conducted a survey on secret tokens for authentication embedded in app code . Our Secret Token Finder (Sect. 4) also finds secret tokens.
# SSL/TLS and cryptography
Misuse of SSL/TLS and immature implementation of original cryptography can easily cause serious risks due to insecure communication. Fahl et al. developed Mallodroid to find apps that misuse SSL/TLS APIs, which can result in man-in-the-middle attacks . We also used MalloDroid to find apps that misuse SSL/TLS (Sect. 4). In addition to issues with secure communication, we have addressed weak keys used for APK certificates. Weak keys can potentially be cracked to obtain a private key, which enables the forging of a signature on a modified APK . Our Weak Certificate Checker discovers cryptographically weak certificates used to sign an APK file (Sect. 4).
# Inter-Component Communication (ICC)
ICC allows individual app components to be independent and enables communication between app components. Felt et al. addressed the permission re-delegation problem, which occurs when an app with permissions performs a privileged task for an app without permissions .
# WebView
WebView† is an Android class that provides the functionalities of a custom WebKit browser to render web pages. Jin et al. revealed a new form of code injection attack using addJavascriptInterface, which is provided by WebView and allows an app to add a bridge between JavaScript and native Java code . Mutchler et al. analyzed a large number of mobile web apps embedded with WebView in terms of unsafe and leaky use of browser functionality. They found that 28% of the apps contained at least one security vulnerability .
Our investigation of vulnerabilities (Sect. 4) for leveraging both original tools (Weak Certificate Checker and Secret Token Finder) and free tools (AndroBugs, MalloDroid, and QARK) broadly covered the above four categories. While AndroBugs finds various types of vulnerabilities across the four categories, other tools find different vulnerabilities that are beyond the scope of AndroBugs.
†iOS also provides similar classes such as UIWebView and WKWebView.
# 8 Paid App Survey at Market Scale
A recent survey effort conducted by Martin et al.  reported that the first research into the mobile marketplaces began in 2010, and, as of the end of 2015, 155 papers have been published.
In 2012, Chakradeo et al. collected 36,710 apps from Google Play and third-party marketplaces, and they proposed lightweight triage techniques for market scale analysis in 2013 . In 2014, Viennot et al. presented a detailed crawler architecture to acquire apps from Google Play in a scalable manner and compiled metadata corresponding to over 1M apps, where they downloaded free apps and the metadata of free and paid apps .
Although the scale of the analyzed data dramatically increases year-by-year with the exponential growth of marketplaces, the analysis of mobile apps was primarily performed in the above representative market-scale studies, except for paid apps. The total number of apps available on Google Play was approximately 2 million, and approximately 10% of these apps were paid apps as of February 2016 . Although the current market share of paid apps should be considerable and paid apps serve an important role in monetization in marketplaces, in most studies conducted at the market scale, only free apps were examined. Thus, the insights obtained from such studies were implicitly confined to free apps. Therefore, the actual security aspects of paid apps have not been considered adequately.
We investigated prior studies focusing on paid apps in terms of the number of paid apps, the origin of apps (market), analyzed object, and analytical purpose (Table 14). While most studies of paid apps covered a broad range of security topics, the analyzed properties were only extracted from market-level metadata, e.g., reviews, ratings, and the number of installs. This means that such studies did not require the actual code of the apps. There have been conventional studies that analyze the code of paid apps; however, only several hundreds of paid apps at most were analyzed. Our work achieves a double-digit increase in dataset size compared to such studies. In addition, our work was accomplished using both the code information of paid apps and market information. To the best of our knowledge, this study is the first to successfully bridge the software analysis of paid apps and market analysis at a large scale and successfully make the security of paid apps understandable at a high level.
# 9. Conclusion
To establish the assessment and remediation of mobile app vulnerabilities, understanding their origins is an imperative approach. This study has focused on mobile app libraries, which constitute most of the code in mobile apps. We have attempted to understand the provenance of mobile app libraries that cause vulnerabilities, which we have classified into four major classes, i.e., information disclosure, SSL/cryptography, ICC, and WebView. By linking the outputs of Droid-L and Droid-V, we can accurately specify the vulnerable libraries contained in apps.
A unique and noteworthy approach of this study is that we used both free and paid apps for our analysis. Since paid apps have different software development and maintenance methods, compared to free apps, they exhibit a different use of libraries or software update frequencies, and these differences affect the characteristics of vulnerabilities in the apps. Our analyses using Droid-L and Droid-V revealed that most vulnerabilities in mobile apps are caused by third-party libraries. We also found that even top paid apps do have vulnerabilities in their libraries, and many have not been updated. It was somewhat surprising that more expensive/popular paid apps tend to have more vulnerabilities. Based on the findings derived through our extensive analysis, we have proposed guidelines for mobile app developers, mobile OS developers, mobile app market operators, mobile app library providers, and vulnerability test developers.
While this work addressed the fundamental research question: “how are the vulnerabilities of mobile apps associated with libraries?”, we can further generalize it to: “where do the vulnerabilities of mobile apps come from?”. There are many research aspects that could address this question; e.g., the app development environments, the economic models of mobile app ecosystems, the sources of information for coding, and the reuse of code. An in-depth study of such research aspects is left for future work.
# IEICE TRANS. INF. & SYST., VOL.E103–D, NO FEBRUARY 2020
290
# Authors
# Takuya Watanabe
received M.E. degree in computer science and engineering from Waseda University, Japan in 2016. Since joining Nippon Telegraph and Telephone Corporation (NTT) in 2016, he has been engaged in research of consumer security and privacy. He is now with the Cyber Security Project of NTT Secure Platform Laboratories.
# Eitaro Shioji
received his B.E. in computer science and M.E. in communications and integrated systems from Tokyo Institute of Technology in 2008 and 2010, respectively. Since joining NTT in 2010, he has been engaged in R&D on computer security. His research interests include software security, program analysis, and reverse engineering.
# Yuta Takata
received his B.E., M.E., and Ph.D. degrees in computer science and engineering from Waseda University, Japan in 2011, 2013, and 2018. He was engaged in R&D of new technologies related to cyber security at NTT from 2013 to 2018. Since joining PwC Cyber Services LLC in 2019, he has been focusing on developing new solutions to effectively analyze and detect cyber attacks.
# Bo Sun
received B.E degree in science from Jilin University in 2007, M.E degree in engineering from Yokohama National University in 2012, and Ph.D degree in engineering from Waseda University in 2018. He was with the University of Waseda as a research associate from 2016 to 2018. He is currently a researcher with the National Institute of Information and Communications Technology and visiting researcher at the University of Waseda. His research interest includes web security, mobile security and offensive security.
# Yuta Ishii
received B.E and M.E degree in computer science from Waseda University in 2015 and 2017. His research interest is network security and mobile security.
# Mitsuaki Akiyama
received his M.E. and Ph.D. degrees in information science from Nara Institute of Science and Technology, Japan in 2007 and 2013. Since joining Nippon Telegraph and Telephone Corporation (NTT) in 2007, he has been engaged in research and development on network security, especially honeypot and malware analysis. He is now with the Cyber Security Project of NTT Secure Platform Laboratories.
# Fumihiro Kanei
received his M.E. degree in computer science from Yokohama National University in 2015. Since joining Nippon Telegraph and Telephone Corporation (NTT) in 2015, he has been engaged in research and development on cyber security, especially mobile security, web security, and program analysis. He is now a researcher in the Cyber Security Project of NTT Secure Platform Laboratories.
# Toshiki Shibahara
is currently a researcher at NTT Secure Platform Laboratories, Tokyo, Japan. He received his B.E. degree in engineering and M.E degree in information science and technology from The University of Tokyo, Japan in 2012 and 2014. Since joining Nippon Telegraph and Telephone Corporation (NTT) in 2014, he has been engaged in research on cyber security and machine learning.
# WATANABE et al.: STUDY ON THE VULNERABILITIES OF FREE AND PAID MOBILE APPS
Takeshi Yagi received his B.E. degree in electrical and electronic engineering and his M.E. degree in science and technology from Chiba University, Japan in 2000 and 2002. He also received his Ph.D. degree in information science and technology from Osaka University, Osaka, Japan in 2013. He joined the Nippon Telegraph and Telephone Corporation (NTT) in 2002 and transferred to NTT Security (Japan) KK in 2018, where he is currently researching honeypots, security-data analysis based on machine learning, and security intelligence technologies such as URL/domain/IP blacklisting and reputation. He is a member of the Institute of Electrical and Electronics Engineers (IEEE) and the Institute of Electrical Engineers of Japan (IEEJ) and IEICE.
Tatsuya Mori is currently an associate professor at Waseda University, Tokyo, Japan. He received B.E. and M.E. degrees in applied physics, and Ph.D. degree in information science from the Waseda University, in 1997, 1999 and 2005, respectively. He joined NTT corporation in 1999. Since then, he has been engaged in the research of measurement and analysis of networked systems and network security. From Mar 2007 to Mar 2008, he was a visiting researcher at the University of Wisconsin-Madison.